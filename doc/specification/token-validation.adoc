= MultiIssuerJWTTokenAuthenticator Token Validation
:toc:
:toclevels: 3
:toc-title: Table of Contents
:sectnums:

link:../Specification.adoc[Back to Main Specification]

== Token Validation Process
_See Requirement link:../Requirements.adoc#NIFI-AUTH-3[NIFI-AUTH-3: Token Validation Requirements]_

=== Token Extraction
_See Requirement link:../Requirements.adoc#NIFI-AUTH-5[NIFI-AUTH-5: Input Requirements]_

The processor extracts JWT tokens from flow files based on the configured token location. In NiFi 2.4.0, there are multiple possible token locations: Authorization header, custom header, or flow file content.

[source,java]
----
private Optional<String> extractToken(FlowFile flowFile, ProcessContext context) {
    String tokenLocation = context.getProperty(TOKEN_LOCATION).getValue();
    
    switch (tokenLocation) {
        case "AUTHORIZATION_HEADER":
            String headerName = context.getProperty(TOKEN_HEADER).getValue();
            return extractTokenFromHeader(flowFile, headerName);
            
        case "CUSTOM_HEADER":
            String customHeaderName = context.getProperty(CUSTOM_HEADER_NAME).getValue();
            return extractTokenFromHeader(flowFile, customHeaderName);
            
        case "FLOW_FILE_CONTENT":
            return extractTokenFromContent(flowFile, context.getSession());
            
        default:
            // Default to Authorization header
            return extractTokenFromHeader(flowFile, "Authorization");
    }
}

private Optional<String> extractTokenFromHeader(FlowFile flowFile, String headerName) {
    String headerValue = flowFile.getAttribute(headerName);

    if (headerValue == null) {
        return Optional.empty();
    }

    // Check for Bearer prefix
    if (headerValue.startsWith("Bearer ")) {
        return Optional.of(headerValue.substring(7));
    }

    // Assume raw token
    return Optional.of(headerValue);
}

private Optional<String> extractTokenFromContent(FlowFile flowFile, ProcessSession session) {
    // Read the flow file content
    final ByteArrayOutputStream baos = new ByteArrayOutputStream();
    session.read(flowFile, inputStream -> StreamUtils.copy(inputStream, baos));
    
    String content = baos.toString(StandardCharsets.UTF_8);
    
    // Trim whitespace and validate
    String token = content.trim();
    if (token.isEmpty()) {
        return Optional.empty();
    }
    
    return Optional.of(token);
}
----

=== Token Structure Validation
_See Requirement link:../Requirements.adoc#NIFI-AUTH-3[NIFI-AUTH-3: Token Validation Requirements]_

In NiFi 2.4.0, the processor performs thorough initial validation of token structure before attempting signature validation:

[source,java]
----
private ValidationResult validateTokenStructure(String tokenString) {
    try {
        // Split the token into parts
        String[] tokenParts = tokenString.split("\\.");
        
        // JWT must have 3 parts: header, payload, signature
        if (tokenParts.length != 3) {
            return ValidationResult.invalid("Invalid token format: token must have header, payload, and signature");
        }
        
        // Validate header
        String headerJson = new String(Base64.getUrlDecoder().decode(tokenParts[0]), StandardCharsets.UTF_8);
        JsonObject header = JsonParser.parseString(headerJson).getAsJsonObject();
        
        // Check required header fields
        if (!header.has("alg")) {
            return ValidationResult.invalid("Invalid token format: missing 'alg' in header");
        }
        
        // Check algorithm security
        String algorithm = header.get("alg").getAsString();
        if ("none".equalsIgnoreCase(algorithm)) {
            return ValidationResult.invalid("Invalid token: 'none' algorithm not accepted");
        }
        
        // Additional validation for header fields
        if (!header.has("typ") || !"JWT".equalsIgnoreCase(header.get("typ").getAsString())) {
            LOGGER.warn(WARNING.TOKEN_MISSING_TYP.format());
            // Don't fail for missing 'typ', but warn about it
        }
        
        // Validate payload structure
        String payloadJson = new String(Base64.getUrlDecoder().decode(tokenParts[1]), StandardCharsets.UTF_8);
        JsonObject payload = JsonParser.parseString(payloadJson).getAsJsonObject();
        
        // Check for required claims
        if (!payload.has("iss")) {
            return ValidationResult.invalid("Invalid token format: missing 'iss' claim");
        }
        
        return ValidationResult.valid();
    } catch (IllegalArgumentException e) {
        // Base64 decoding failed
        return ValidationResult.invalid("Invalid token format: not properly Base64Url encoded");
    } catch (JsonSyntaxException e) {
        // JSON parsing failed
        return ValidationResult.invalid("Invalid token format: header or payload is not valid JSON");
    } catch (Exception e) {
        // Unexpected error
        LOGGER.error(e, ERROR.TOKEN_VALIDATION_FAILED.format(e.getMessage()));
        return ValidationResult.invalid("Token validation failed: " + e.getMessage());
    }
}
----

=== Signature Validation
_See Requirement link:../Requirements.adoc#NIFI-AUTH-3[NIFI-AUTH-3: Token Validation Requirements]_

NiFi 2.4.0 implements improved token validation with improved security features using the https://github.com/cuioss/cui-jwt-validation[cui-jwt-validation] library version 2.0.

[source,java]
----
/**
 * Enhanced processor implementation for JWT token validation in NiFi 2.4.0.
 */
public class MultiIssuerJWTTokenAuthenticator extends AbstractProcessor {

    private static final CuiLogger LOGGER = new CuiLogger(MultiIssuerJWTTokenAuthenticator.class);

    // TokenValidator instance for validating tokens
    private volatile TokenValidator tokenValidator;

    // Lock for thread-safe initialization
    private final Object lock = new Object();

    /**
     * Validates a token using the TokenValidator from cui-jwt-validation 2.0.
     * 
     * @param tokenString The JWT token string to validate
     * @return An Optional containing the parsed token if valid, or empty if invalid
     */
    private Optional<AccessTokenContent> validateToken(String tokenString) {
        // Get the TokenValidator
        TokenValidator validator = getTokenValidator();
        return validator.createAccessToken(tokenString);
    }

    /**
     * Gets or initializes the TokenValidator with improved error handling.
     * 
     * @return The TokenValidator instance
     */
    private TokenValidator getTokenValidator() {
        if (tokenValidator == null) {
            synchronized (lock) {
                if (tokenValidator == null) {
                    tokenValidator = initializeTokenValidator();
                }
            }
        }
        return tokenValidator;
    }

    /**
     * Initializes the TokenValidator with configured issuers.
     * NiFi 2.4.0 adds improved support for multiple key types and algorithms.
     * 
     * @return A new TokenValidator instance
     */
    private TokenValidator initializeTokenValidator() {
        List<IssuerConfig> issuers = new ArrayList<>();

        // Get dynamic properties for issuers
        Map<PropertyDescriptor, String> properties = getProperties();
        for (Map.Entry<PropertyDescriptor, String> entry : properties.entrySet()) {
            PropertyDescriptor descriptor = entry.getKey();

            // Skip static properties
            if (!descriptor.isDynamic()) {
                continue;
            }

            String issuerName = descriptor.getName();
            String issuerConfig = entry.getValue();
            IssuerConfig config;

            // Handle different issuer config types
            if (issuerConfig.startsWith("http")) {
                // JWKS URL configuration
                config = IssuerConfig.builder()
                    .jwksIssuer(issuerName)
                    .jwksEndpoint(issuerConfig)
                    .jwksRefreshInterval(getRefreshInterval())
                    .supportedAlgorithms(getSupportedAlgorithms())
                    .build();
                
                LOGGER.debug("Added JWKS issuer config for '%s' with endpoint '%s'", 
                    issuerName, issuerConfig);
            } else if (issuerConfig.contains("-----BEGIN PUBLIC KEY-----")) {
                // Direct public key configuration
                config = IssuerConfig.builder()
                    .jwksIssuer(issuerName)
                    .publicKey(issuerConfig)
                    .supportedAlgorithms(getSupportedAlgorithms())
                    .build();
                
                LOGGER.debug("Added public key issuer config for '%s'", issuerName);
            } else {
                throw new ProcessException("Invalid issuer configuration for '" + 
                    issuerName + "'. Must be a JWKS URL or PEM public key");
            }

            issuers.add(config);
        }

        if (issuers.isEmpty()) {
            throw new ProcessException("No token issuers configured");
        }

        // Create token validator options with enhanced security in NiFi 2.4.0
        TokenValidatorOptions options = TokenValidatorOptions.builder()
            .requireStrongKeys(true) // Ensure strong keys (RSA ≥ 2048 bits, EC ≥ 256 bits)
            .requireKeyIdHeader(true) // Require 'kid' header in tokens
            .rejectInsecureAlgorithms(true) // Reject weak algorithms
            .build();

        // Create the TokenValidator with all issuers and options
        return new TokenValidator(options, issuers.toArray(new IssuerConfig[0]));
    }

    /**
     * Gets the supported signature algorithms.
     * NiFi 2.4.0 adds support for additional algorithms.
     */
    private Set<String> getSupportedAlgorithms() {
        // Support RS256, RS384, RS512, ES256, ES384, ES512, PS256, PS384, PS512
        return Set.of("RS256", "RS384", "RS512", "ES256", "ES384", "ES512", "PS256", "PS384", "PS512");
    }
}
----

=== Claims Validation
_See Requirement link:../Requirements.adoc#NIFI-AUTH-3[NIFI-AUTH-3: Token Validation Requirements]_

In NiFi 2.4.0, the processor implements enhanced claims validation features:

[source,java]
----
/**
 * Validates the claims in a token with enhanced validation in NiFi 2.4.0.
 * 
 * @param token The parsed access token to validate
 * @return A ValidationResult indicating whether the claims are valid
 */
private ValidationResult validateClaims(AccessTokenContent token, ProcessContext context) {
    // Check expiration time
    if (token.isExpired()) {
        return ValidationResult.invalid("Token has expired");
    }

    // Check not-before time
    if (token.getNotBeforeTime() != null && 
        token.getNotBeforeTime().isAfter(Instant.now())) {
        return ValidationResult.invalid("Token not yet valid");
    }
    
    // NiFi 2.4.0: Check audience if configured
    String requiredAudience = context.getProperty(REQUIRED_AUDIENCE).getValue();
    if (requiredAudience != null && !requiredAudience.isEmpty()) {
        boolean audienceMatch = false;
        
        // Check if token has the required audience
        Set<String> audiences = token.getAudiences();
        if (audiences != null) {
            for (String audience : audiences) {
                if (audience.equals(requiredAudience)) {
                    audienceMatch = true;
                    break;
                }
            }
        }
        
        if (!audienceMatch) {
            return ValidationResult.invalid("Token audience does not include required audience: " + 
                                          requiredAudience);
        }
    }
    
    // Additional claim validations can be configured via dynamic properties
    Map<PropertyDescriptor, String> properties = context.getProperties();
    for (Map.Entry<PropertyDescriptor, String> entry : properties.entrySet()) {
        PropertyDescriptor descriptor = entry.getKey();
        
        // Look for claim validation properties
        if (descriptor.getName().startsWith("validate-claim:")) {
            String claimName = descriptor.getName().substring("validate-claim:".length());
            String requiredValue = entry.getValue();
            
            // Get the actual claim value
            Object actualValue = token.getJsonWebToken().getClaim(claimName);
            String actualValueStr = (actualValue != null) ? actualValue.toString() : null;
            
            // Compare values
            if (!Objects.equals(requiredValue, actualValueStr)) {
                return ValidationResult.invalid("Token claim '" + claimName + "' value mismatch. " +
                    "Expected: '" + requiredValue + "', Actual: '" + actualValueStr + "'");
            }
        }
    }

    return ValidationResult.valid();
}
----

=== Authorization Rules
_See Requirement link:../Requirements.adoc#NIFI-AUTH-7.4[NIFI-AUTH-7.4: Authorization Configuration]_

In NiFi 2.4.0, the processor implements enhanced authorization rule checking:

[source,java]
----
/**
 * Validates authorization rules based on token scopes and roles.
 * Enhanced in NiFi 2.4.0 to support roles and expressions.
 * 
 * @param token The parsed access token to validate
 * @param context The process context
 * @return A ValidationResult indicating whether the authorization is valid
 */
private ValidationResult validateAuthorization(AccessTokenContent token, ProcessContext context) {
    // Only validate authorization if required
    if (!context.getProperty(REQUIRE_VALID_TOKEN).asBoolean()) {
        return ValidationResult.valid();
    }
    
    // Check required scopes
    String scopesProperty = context.getProperty(REQUIRED_SCOPES).getValue();
    if (scopesProperty != null && !scopesProperty.isEmpty()) {
        Set<String> requiredScopes = Arrays.stream(scopesProperty.split(","))
            .map(String::trim)
            .collect(Collectors.toSet());
        
        // Determine missing scopes
        Set<String> tokenScopes = token.getScopes();
        Set<String> missingScopes = new HashSet<>(requiredScopes);
        missingScopes.removeAll(tokenScopes);
        
        if (!missingScopes.isEmpty()) {
            return ValidationResult.invalid("Token missing required scopes: " + 
                String.join(", ", missingScopes));
        }
    }
    
    // Check required roles
    String rolesProperty = context.getProperty(REQUIRED_ROLES).getValue();
    if (rolesProperty != null && !rolesProperty.isEmpty()) {
        Set<String> requiredRoles = Arrays.stream(rolesProperty.split(","))
            .map(String::trim)
            .collect(Collectors.toSet());
        
        // Get token roles from 'roles' claim or 'realm_access.roles'
        Set<String> tokenRoles = extractRolesFromToken(token);
        
        // Determine missing roles
        Set<String> missingRoles = new HashSet<>(requiredRoles);
        missingRoles.removeAll(tokenRoles);
        
        if (!missingRoles.isEmpty()) {
            return ValidationResult.invalid("Token missing required roles: " + 
                String.join(", ", missingRoles));
        }
    }
    
    // NiFi 2.4.0: Check authorization expression if configured
    String expression = context.getProperty(AUTHORIZATION_EXPRESSION).getValue();
    if (expression != null && !expression.isEmpty()) {
        // Use JEL (Jakarta Expression Language) for evaluating expressions
        try {
            ELProcessor processor = new ELProcessor();
            
            // Add token claims as variables
            Map<String, Object> claims = token.getJsonWebToken().getClaims();
            for (Map.Entry<String, Object> claim : claims.entrySet()) {
                processor.defineBean(claim.getKey(), claim.getValue());
            }
            
            // Add special variables
            processor.defineBean("scopes", token.getScopes());
            processor.defineBean("roles", extractRolesFromToken(token));
            processor.defineBean("now", Instant.now());
            
            // Evaluate expression
            Boolean result = (Boolean) processor.eval(expression);
            if (result == null || !result) {
                return ValidationResult.invalid("Token failed authorization expression: " + expression);
            }
        } catch (Exception e) {
            LOGGER.error(e, ERROR.AUTHORIZATION_EXPRESSION_FAILED.format(e.getMessage()));
            return ValidationResult.invalid("Error evaluating authorization expression: " + e.getMessage());
        }
    }
    
    return ValidationResult.valid();
}

/**
 * Extracts roles from a JWT token.
 * 
 * @param token The access token
 * @return A set of role strings
 */
private Set<String> extractRolesFromToken(AccessTokenContent token) {
    Set<String> roles = new HashSet<>();
    
    // Look for direct 'roles' claim
    Object rolesClaim = token.getJsonWebToken().getClaim("roles");
    if (rolesClaim instanceof List) {
        for (Object role : (List<?>) rolesClaim) {
            if (role != null) {
                roles.add(role.toString());
            }
        }
    } else if (rolesClaim instanceof String) {
        // Handle comma or space-separated roles
        for (String role : ((String) rolesClaim).split("[,\\s]+")) {
            if (!role.isEmpty()) {
                roles.add(role);
            }
        }
    }
    
    // Look for Keycloak-style 'realm_access.roles' claim
    Object realmAccess = token.getJsonWebToken().getClaim("realm_access");
    if (realmAccess instanceof Map) {
        Object realmRoles = ((Map<?, ?>) realmAccess).get("roles");
        if (realmRoles instanceof List) {
            for (Object role : (List<?>) realmRoles) {
                if (role != null) {
                    roles.add(role.toString());
                }
            }
        }
    }
    
    return roles;
}

/**
 * Extracts claims from a token and converts them to a map of attributes.
 * Enhanced in NiFi 2.4.0 with better handling of complex objects.
 * 
 * @param token The parsed access token
 * @return A map of claim names to string values
 */
private Map<String, String> extractClaims(AccessTokenContent token) {
    Map<String, String> claims = new HashMap<>();

    // Add standard claims
    claims.put("jwt.subject", token.getSubjectId());
    claims.put("jwt.issuer", token.getIssuer());
    claims.put("jwt.validatedAt", Instant.now().toString());
    claims.put("jwt.authorization.passed", "true");

    // Add expiration time if available
    token.getExpirationTime().ifPresent(expTime -> 
        claims.put("jwt.exp", String.valueOf(expTime.getEpochSecond())));

    // Add issued-at time if available
    token.getIssuedAt().ifPresent(iatTime -> 
        claims.put("jwt.iat", String.valueOf(iatTime.getEpochSecond())));

    // Add scopes
    Set<String> scopes = token.getScopes();
    if (!scopes.isEmpty()) {
        claims.put("jwt.scope", String.join(" ", scopes));
    }

    // Add additional custom claims with improved handling of complex objects
    Map<String, Object> customClaims = token.getJsonWebToken().getClaims();
    for (Map.Entry<String, Object> entry : customClaims.entrySet()) {
        String key = entry.getKey();
        Object value = entry.getValue();
        
        // Skip null values
        if (value == null) {
            continue;
        }

        // Handle different value types
        if (value instanceof String || value instanceof Number || value instanceof Boolean) {
            // Handle simple values directly
            claims.put("jwt.claims." + key, String.valueOf(value));
        } else if (value instanceof Collection || value instanceof Map) {
            // Convert complex objects to JSON
            try {
                String jsonValue = new Gson().toJson(value);
                claims.put("jwt.claims." + key, jsonValue);
            } catch (Exception e) {
                LOGGER.warn(WARN.COMPLEX_CLAIM_CONVERSION_FAILED.format(key, e.getMessage()));
            }
        }
    }

    return claims;
}
----

== See also
* link:token-factory-manager.adoc[Token Factory Manager]
* link:security.adoc[Security Considerations]
* link:error-handling.adoc[Error Handling]
