= MultiIssuerJWTTokenAuthenticator Token Validation
:toc:
:toclevels: 3
:toc-title: Table of Contents
:sectnums:

link:../Specification.adoc[Back to Main Specification]

== Token Validation Process
_See Requirement link:../Requirements.adoc#NIFI-AUTH-3[NIFI-AUTH-3: Token Validation Requirements]_

=== Token Extraction
_See Requirement link:../Requirements.adoc#NIFI-AUTH-5[NIFI-AUTH-5: Input Requirements]_

The processor extracts JWT tokens from flow files based on the configured token location. In NiFi 2.4.0, there are multiple possible token locations: Authorization header, custom header, or flow file content.

[source,java]
----
private Optional<String> extractToken(FlowFile flowFile, ProcessContext context) {
    String tokenLocation = context.getProperty(TOKEN_LOCATION).getValue();
    
    switch (tokenLocation) {
        case "AUTHORIZATION_HEADER":
            String headerName = context.getProperty(TOKEN_HEADER).getValue();
            return extractTokenFromHeader(flowFile, headerName);
            
        case "CUSTOM_HEADER":
            String customHeaderName = context.getProperty(CUSTOM_HEADER_NAME).getValue();
            return extractTokenFromHeader(flowFile, customHeaderName);
            
        case "FLOW_FILE_CONTENT":
            return extractTokenFromContent(flowFile, context.getSession());
            
        default:
            // Default to Authorization header
            return extractTokenFromHeader(flowFile, "Authorization");
    }
}

// ...existing code...
----

== Integration with cui-jwt-validation Library

The MultiIssuerJWTTokenAuthenticator processor leverages the cui-jwt-validation library rather than implementing token validation logic directly. The library handles token structure validation, signature verification, claim validation including audience checks, and other aspects of JWT token processing.

=== Library Features Used

The processor utilizes the following key features from the cui-jwt-validation library:

* **TokenValidator**: Main entry point for token operations
* **IssuerConfig**: Configuration for each trusted token issuer with customizable validation settings
* **AccessTokenContent**: Parsed token with convenient access to claims and validation status
* **HttpJwksLoaderConfig**: Configuration for JWKS key loading with automatic key rotation

=== How the Processor Uses cui-jwt-validation

In NiFi 2.4.0, the processor initializes and uses the cui-jwt-validation library as follows:

[source,java]
----
/**
 * Enhanced processor implementation for JWT token validation in NiFi 2.4.0.
 */
public class MultiIssuerJWTTokenAuthenticator extends AbstractProcessor {

    private static final CuiLogger LOGGER = new CuiLogger(MultiIssuerJWTTokenAuthenticator.class);

    // TokenValidator instance for validating tokens
    private volatile TokenValidator tokenValidator;

    // Lock for thread-safe initialization
    private final Object lock = new Object();

    /**
     * Validates a token using the TokenValidator from cui-jwt-validation.
     * 
     * @param tokenString The JWT token string to validate
     * @return An Optional containing the parsed token if valid, or empty if invalid
     */
    private Optional<AccessTokenContent> validateToken(String tokenString) {
        // Get the TokenValidator
        TokenValidator validator = getTokenValidator();
        return validator.createAccessToken(tokenString);
    }

    /**
     * Gets or initializes the TokenValidator with improved error handling.
     * 
     * @return The TokenValidator instance
     */
    private TokenValidator getTokenValidator() {
        if (tokenValidator == null) {
            synchronized (lock) {
                if (tokenValidator == null) {
                    tokenValidator = initializeTokenValidator();
                }
            }
        }
        return tokenValidator;
    }

    /**
     * Initializes the TokenValidator with configured issuers.
     * 
     * @return A new TokenValidator instance
     */
    private TokenValidator initializeTokenValidator() {
        List<IssuerConfig> issuers = new ArrayList<>();

        // Get dynamic properties for issuers
        Map<PropertyDescriptor, String> properties = getProperties();
        for (Map.Entry<PropertyDescriptor, String> entry : properties.entrySet()) {
            PropertyDescriptor descriptor = entry.getKey();

            // Skip static properties
            if (!descriptor.isDynamic()) {
                continue;
            }

            String issuerName = descriptor.getName();
            String issuerUrl = entry.getValue();
            IssuerConfig config;

            // Handle different issuer config types
            if (issuerUrl.startsWith("http")) {
                // Create HTTP JWKS loader config with refresh interval
                HttpJwksLoaderConfig httpConfig = HttpJwksLoaderConfig.builder()
                    .jwksUrl(issuerUrl)
                    .refreshIntervalSeconds(getRefreshInterval())
                    .build();
                
                // Configure issuer with HTTP-based JWKS loading
                config = IssuerConfig.builder()
                    .issuer(issuerName)
                    .httpJwksLoaderConfig(httpConfig)
                    .expectedAudience(getRequiredAudience()) // Set expected audience if configured
                    .build();
                
                LOGGER.debug("Added JWKS issuer config for '%s' with endpoint '%s'", 
                    issuerName, issuerUrl);
            } else if (issuerUrl.contains("-----BEGIN PUBLIC KEY-----")) {
                // Direct public key configuration
                config = IssuerConfig.builder()
                    .issuer(issuerName)
                    .jwksContent(createJwksContentFromPublicKey(issuerUrl))
                    .expectedAudience(getRequiredAudience()) // Set expected audience if configured
                    .build();
                
                LOGGER.debug("Added public key issuer config for '%s'", issuerName);
            } else {
                throw new ProcessException("Invalid issuer configuration for '" + 
                    issuerName + "'. Must be a JWKS URL or PEM public key");
            }

            issuers.add(config);
        }

        if (issuers.isEmpty()) {
            throw new ProcessException("No token issuers configured");
        }

        // Create a validator with all configured issuers
        return new TokenValidator(createParserConfig(), issuers.toArray(new IssuerConfig[0]));
    }

    /**
     * Creates a ParserConfig with security settings for token processing.
     */
    private ParserConfig createParserConfig() {
        return ParserConfig.builder()
            .maxTokenSize(8 * 1024)         // Limit token size to 8KB
            .maxPayloadSize(8 * 1024)       // Limit payload size to 8KB
            .logWarningsOnDecodeFailure(true) // Log warnings when token decoding fails
            .build();
    }
    
    /**
     * Gets the refresh interval for JWKS in seconds.
     */
    private int getRefreshInterval() {
        String intervalProperty = getProperty(JWKS_REFRESH_INTERVAL).getValue();
        // Convert from minutes to seconds
        return Integer.parseInt(intervalProperty) * 60;
    }
    
    /**
     * Gets the required audience if configured.
     */
    private String getRequiredAudience() {
        return getProperty(REQUIRED_AUDIENCE).getValue();
    }
}
----

== Handling TokenValidator Lifecycle in NiFi

The cui-jwt-validation library's `TokenValidator` is designed to be stateful and maintain caches for performance optimization, particularly for JWKS keys and validation results. In a NiFi processor, it's important to preserve this instance between invocations while handling configuration changes appropriately.

=== TokenValidator Stateful Behavior

The `TokenValidator` maintains important caches:

* JWKS keys from remote endpoints
* Public keys parsed from the JWKS
* Background refresh tasks for key rotation

Creating a new `TokenValidator` for each flowfile would defeat these caching mechanisms and cause:

1. Excessive network traffic to JWKS endpoints
2. Higher latency for token validation
3. Potential rate limiting or blocking from identity providers
4. Increased CPU and memory usage

=== Proper Implementation in NiFi

To properly implement the TokenValidator in a NiFi processor:

[source,java]
----
/**
 * Processor implementation for JWT token validation using cui-jwt-validation.
 */
public class MultiIssuerJWTTokenAuthenticator extends AbstractProcessor {

    private static final CuiLogger LOGGER = new CuiLogger(MultiIssuerJWTTokenAuthenticator.class);

    // TokenValidator instance for validating tokens - volatile for thread-safety
    private volatile TokenValidator tokenValidator;

    // Lock for thread-safe initialization
    private final Object lock = new Object();
    
    // Track if configuration has changed
    private volatile boolean configurationChanged = true;

    // Store the last configuration hash to detect changes
    private volatile int lastConfigurationHash;

    @Override
    public void onPropertyModified(PropertyDescriptor descriptor, String oldValue, String newValue) {
        // Mark configuration as changed when properties change
        configurationChanged = true;
        LOGGER.debug("Configuration changed, TokenValidator will be recreated on next use");
    }
    
    /**
     * Gets or initializes the TokenValidator.
     * 
     * @return The TokenValidator instance
     */
    private TokenValidator getTokenValidator() {
        if (tokenValidator == null || configurationChanged) {
            synchronized (lock) {
                // Double-check under lock
                if (tokenValidator == null || configurationChanged) {
                    // Create new configuration hash
                    int newConfigHash = calculateConfigurationHash();
                    
                    // Only recreate if hash changed or validator is null
                    if (tokenValidator == null || lastConfigurationHash != newConfigHash) {
                        LOGGER.debug("Initializing TokenValidator with current configuration");
                        tokenValidator = initializeTokenValidator();
                        lastConfigurationHash = newConfigHash;
                    }
                    
                    // Reset flag
                    configurationChanged = false;
                }
            }
        }
        return tokenValidator;
    }
    
    /**
     * Calculate a hash of the current configuration to detect changes.
     */
    private int calculateConfigurationHash() {
        // Get all properties and create a string representation
        StringBuilder configString = new StringBuilder();
        Map<PropertyDescriptor, String> properties = getProperties();
        
        // Sort keys for consistency
        List<PropertyDescriptor> sortedKeys = new ArrayList<>(properties.keySet());
        sortedKeys.sort(Comparator.comparing(PropertyDescriptor::getName));
        
        // Build string representation
        for (PropertyDescriptor descriptor : sortedKeys) {
            configString.append(descriptor.getName())
                        .append("=")
                        .append(properties.get(descriptor))
                        .append(";");
        }
        
        // Return hash code
        return configString.toString().hashCode();
    }

    /**
     * Initializes the TokenValidator with configured issuers.
     * 
     * @return A new TokenValidator instance
     */
    private TokenValidator initializeTokenValidator() {
        List<IssuerConfig> issuers = new ArrayList<>();

        // Get all properties from context
        Map<PropertyDescriptor, String> properties = getProperties();
        
        // Process issuer configurations from dynamic properties
        for (Map.Entry<PropertyDescriptor, String> entry : properties.entrySet()) {
            PropertyDescriptor descriptor = entry.getKey();

            // Skip static properties
            if (!descriptor.isDynamic()) {
                continue;
            }

            String issuerName = descriptor.getName();
            String issuerUrl = entry.getValue();
            
            // Check if this issuer is enabled
            boolean isEnabled = true; // Default to enabled
            
            // Look for an "enabled" property for this issuer
            PropertyDescriptor enabledProp = getPropertyDescriptor(issuerName + ".enabled");
            if (enabledProp != null) {
                String enabledValue = properties.get(enabledProp);
                if (enabledValue != null) {
                    isEnabled = Boolean.parseBoolean(enabledValue);
                }
            }
            
            // Skip disabled issuers
            if (!isEnabled) {
                LOGGER.debug("Skipping disabled issuer: %s", issuerName);
                continue;
            }

            IssuerConfig config;
            // Handle different issuer config types
            if (issuerUrl.startsWith("http")) {
                // Create HTTP JWKS loader config with refresh interval
                HttpJwksLoaderConfig httpConfig = HttpJwksLoaderConfig.builder()
                    .jwksUrl(issuerUrl)
                    .refreshIntervalSeconds(getRefreshInterval())
                    .build();
                
                // Configure issuer with HTTP-based JWKS loading
                config = IssuerConfig.builder()
                    .issuer(issuerName)
                    .httpJwksLoaderConfig(httpConfig)
                    .expectedAudience(getRequiredAudience()) // Set expected audience if configured
                    .build();
                
                LOGGER.debug("Added JWKS issuer config for '%s' with endpoint '%s'", 
                    issuerName, issuerUrl);
            } else if (issuerUrl.contains("-----BEGIN PUBLIC KEY-----")) {
                // Direct public key configuration
                config = IssuerConfig.builder()
                    .issuer(issuerName)
                    .jwksContent(createJwksContentFromPublicKey(issuerUrl))
                    .expectedAudience(getRequiredAudience()) // Set expected audience if configured
                    .build();
                
                LOGGER.debug("Added public key issuer config for '%s'", issuerName);
            } else {
                throw new ProcessException("Invalid issuer configuration for '" + 
                    issuerName + "'. Must be a JWKS URL or PEM public key");
            }

            issuers.add(config);
        }

        if (issuers.isEmpty()) {
            throw new ProcessException("No enabled token issuers configured");
        }

        // Create a validator with all configured issuers
        return new TokenValidator(createParserConfig(), issuers.toArray(new IssuerConfig[0]));
    }

    /**
     * Gets a PropertyDescriptor for a specific property name.
     */
    private PropertyDescriptor getPropertyDescriptor(String propertyName) {
        for (PropertyDescriptor descriptor : getPropertyDescriptors()) {
            if (descriptor.getName().equals(propertyName)) {
                return descriptor;
            }
        }
        return null;
    }
    
    // ... existing code ...
}
----

=== Special NiFi Lifecycle Considerations

NiFi processors have specific lifecycle events that need to be handled:

1. **@OnScheduled**: Perform initialization when the processor is scheduled
2. **@OnStopped**: Clean up resources when the processor is stopped
3. **@OnUnscheduled**: Optional cleanup when the processor is unscheduled

Example implementation:

[source,java]
----
/**
 * Initialize the processor when scheduled.
 */
@OnScheduled
public void onScheduled(final ProcessContext context) {
    // Ensure TokenValidator is initialized
    getTokenValidator();
    LOGGER.info("TokenValidator initialized with %d issuers", getIssuerCount());
}

/**
 * Clean up resources when the processor is stopped.
 */
@OnStopped
public void onStopped() {
    synchronized (lock) {
        // Clean up TokenValidator resources if needed
        if (tokenValidator != null) {
            // Allow the TokenValidator to be garbage collected
            tokenValidator = null;
            LOGGER.debug("TokenValidator resources released");
        }
    }
}
----
=== Thread Safety Considerations

Multiple NiFi threads may access the TokenValidator concurrently:

1. Use `volatile` for the TokenValidator instance
2. Synchronize initialization with a lock object
3. Use double-checked locking for efficiency
4. Make configuration change detection thread-safe

=== Resource Management

The TokenValidator uses resources that should be properly managed:

1. HTTP connections for JWKS endpoints
2. Background threads for key rotation
3. Memory for caches

By maintaining a single TokenValidator instance and only recreating it when configuration changes, the processor can benefit from the library's caching while properly managing resources in the NiFi environment.

=== Authorization Checking

While the cui-jwt-validation library handles basic token validation including issuer, expiration, and audience checks, the processor adds additional authorization checks for specific NiFi use cases:

[source,java]
----
/**
 * Validates authorization rules based on token scopes and roles.
 * 
 * @param token The parsed access token to validate
 * @param context The process context
 * @return A ValidationResult indicating whether the authorization is valid
 */
private ValidationResult validateAuthorization(AccessTokenContent token, ProcessContext context) {
    // Only validate authorization if required
    if (!context.getProperty(REQUIRE_VALID_TOKEN).asBoolean()) {
        return ValidationResult.valid();
    }
    
    // Check required scopes using determineMissingScopes from AccessTokenContent
    String scopesProperty = context.getProperty(REQUIRED_SCOPES).getValue();
    if (scopesProperty != null && !scopesProperty.isEmpty()) {
        Set<String> requiredScopes = Arrays.stream(scopesProperty.split(","))
            .map(String::trim)
            .collect(Collectors.toSet());
        
        Set<String> missingScopes = token.determineMissingScopes(requiredScopes);
        if (!missingScopes.isEmpty()) {
            return ValidationResult.invalid("Token missing required scopes: " + 
                String.join(", ", missingScopes));
        }
    }
    
    // Check required roles - leveraging determineMissingRoles if available
    String rolesProperty = context.getProperty(REQUIRED_ROLES).getValue();
    if (rolesProperty != null && !rolesProperty.isEmpty()) {
        Set<String> requiredRoles = Arrays.stream(rolesProperty.split(","))
            .map(String::trim)
            .collect(Collectors.toSet());
        
        // Use determineMissingRoles if it exists, otherwise calculate manually
        Set<String> missingRoles = token.determineMissingRoles(requiredRoles);
        if (!missingRoles.isEmpty()) {
            return ValidationResult.invalid("Token missing required roles: " + 
                String.join(", ", missingRoles));
        }
    }
    
    return ValidationResult.valid();
}
----

=== Flow File Attribute Generation

After token validation, the processor extracts token claims and adds them to the flow file's attributes, using a simplified consistent approach:

[source,java]
----
/**
 * Extracts claims from a token and converts them to a map of attributes.
 * 
 * @param token The parsed access token
 * @return A map of claim names to string values
 */
private Map<String, String> extractClaims(AccessTokenContent token) {
    Map<String, String> claims = new HashMap<>();

    // Add validation metadata
    claims.put("jwt.validatedAt", Instant.now().toString());
    claims.put("jwt.authorization.passed", "true");
    
    // Add all token claims with consistent "jwt.content." prefix
    token.getClaims().forEach((key, claimValue) -> {
        claims.put("jwt.content." + key, claimValue.getOriginalString());
    });
    
    return claims;
}
----

This approach:

1. Uses a consistent namespace ("jwt.content.") for all token claims
2. Leverages the `getClaims()` method which returns all claims as ClaimValue objects
3. Uses `getOriginalString()` to properly convert all value types to strings
4. Eliminates the need to distinguish between standard and custom claims
5. Simplifies the code significantly while maintaining full functionality

=== Security Event Monitoring

The cui-jwt-validation library provides a SecurityEventCounter that tracks security events during token validation. The processor can access this counter for monitoring and reporting:

[source,java]
----
/**
 * Retrieves security event metrics from the TokenValidator.
 */
private void logSecurityMetrics() {
    if (tokenValidator != null) {
        SecurityEventCounter counter = tokenValidator.getSecurityEventCounter();
        
        LOGGER.info("Token validation metrics - " +
            "Processed: %d, Valid: %d, Invalid: %d, Expired: %d, Malformed: %d",
            counter.getTotalProcessedTokens(),
            counter.getValidTokens(),
            counter.getInvalidTokens(),
            counter.getExpiredTokens(),
            counter.getMalformedTokens());
    }
}
----

== Best Practices

Based on the cui-jwt-validation library recommendations, the processor follows these best practices:

1. Uses the TokenValidator as the main entry point for all token operations
2. Configures IssuerConfig with appropriate validation settings for each issuer
3. Uses ParserConfig to set token size limits and security settings
4. Requires HTTPS for JWKS endpoints in production environments
5. Validates token scopes and roles before granting access to protected resources
6. Sets appropriate refresh intervals for JWKS key rotation
7. Implements proper error handling for token validation failures

== See also

* link:token-factory-manager.adoc[Token Factory Manager]
* link:security.adoc[Security Considerations]
* link:error-handling.adoc[Error Handling]
* link:../Usage.adoc[cui-jwt-validation Usage Guide]
