= MultiIssuerJWTTokenAuthenticator Token Validation
:toc:
:toclevels: 3
:toc-title: Table of Contents
:sectnums:
:imagesdir: ../plantuml

link:../Specification.adoc[Back to Main Specification]

== Implementation Status

=== Implementation Classes
* link:../../nifi-cuioss-processors/src/main/java/de/cuioss/nifi/processors/auth/MultiIssuerJWTTokenAuthenticator.java[MultiIssuerJWTTokenAuthenticator] -- Main processor with token validation
* link:../../nifi-cuioss-processors/src/main/java/de/cuioss/nifi/processors/auth/util/AuthorizationValidator.java[AuthorizationValidator] -- Scope and role validation
* link:../../nifi-cuioss-ui/src/main/java/de/cuioss/nifi/ui/service/JwtValidationService.java[JwtValidationService] -- UI token verification service

=== Verification
* link:../../nifi-cuioss-processors/src/test/java/de/cuioss/nifi/processors/auth/MultiIssuerJWTTokenAuthenticatorTest.java[MultiIssuerJWTTokenAuthenticatorTest]
* link:../../nifi-cuioss-processors/src/test/java/de/cuioss/nifi/processors/auth/MultiIssuerJWTTokenAuthenticatorExtendedTest.java[MultiIssuerJWTTokenAuthenticatorExtendedTest] -- RS256 signed token tests
* link:../../nifi-cuioss-processors/src/test/java/de/cuioss/nifi/processors/auth/util/AuthorizationValidatorTest.java[AuthorizationValidatorTest]
* link:../../nifi-cuioss-ui/src/test/java/de/cuioss/nifi/ui/service/JwtValidationServiceTest.java[JwtValidationServiceTest]

== Token Validation Overview
_See Requirement link:../Requirements.adoc#NIFI-AUTH-3[NIFI-AUTH-3: Token Validation Requirements]_

== Token Validation Process
_See Requirement link:../Requirements.adoc#NIFI-AUTH-3[NIFI-AUTH-3: Token Validation Requirements]_

.Token Validation Architecture
image::token-validation-flow.png[Token Validation Flow]

=== Token Extraction
_See Requirement link:../Requirements.adoc#NIFI-AUTH-5[NIFI-AUTH-5: Input Requirements]_

The processor extracts JWT tokens from flow files based on the configured token location. There are multiple possible token locations: Authorization header, custom header, or flow file content.

Token extraction is implemented in link:../../nifi-cuioss-processors/src/main/java/de/cuioss/nifi/processors/auth/MultiIssuerJWTTokenAuthenticator.java[MultiIssuerJWTTokenAuthenticator] (`onTrigger` method), which delegates to `extractTokenFromHeader` and `extractTokenFromContent` based on the configured token location. See also link:../../nifi-cuioss-processors/src/main/java/de/cuioss/nifi/processors/auth/JWTTokenAuthenticator.java[JWTTokenAuthenticator] for the simplified extraction-only processor.

For more information about token location configuration, see link:configuration.adoc#token-location[Token Location Configuration].

== Integration with OAuth-Sheriff Library

The MultiIssuerJWTTokenAuthenticator processor leverages the OAuth-Sheriff library rather than implementing token validation logic directly. The library handles token structure validation, signature verification, claim validation including audience checks, and other aspects of JWT token processing.

=== Library Features Used

The processor utilizes the following key features from the OAuth-Sheriff library:

* **TokenValidator**: Main entry point for token operations
* **IssuerConfig**: Configuration for each trusted token issuer with customizable validation settings
* **AccessTokenContent**: Parsed token with convenient access to claims and validation status
* **HttpJwksLoaderConfig**: Configuration for JWKS key loading with automatic key rotation

For more details on the OAuth-Sheriff library, see link:../library/oauth-sheriff/Usage.adoc[Library Documentation].

=== How the Processor Uses OAuth-Sheriff

The processor initializes and uses the OAuth-Sheriff library as follows:

Token validation is implemented in link:../../nifi-cuioss-processors/src/main/java/de/cuioss/nifi/processors/auth/MultiIssuerJWTTokenAuthenticator.java[MultiIssuerJWTTokenAuthenticator] using the `TokenValidator.createAccessToken()` method from OAuth-Sheriff. For details on the TokenValidator initialization, see link:technical-components.adoc#tokenvalidator[TokenValidator Component].

== Handling TokenValidator Lifecycle in NiFi

The OAuth-Sheriff library's `TokenValidator` is designed to be stateful and maintain caches for performance optimization, particularly for JWKS keys and validation results. In a NiFi processor, it's important to preserve this instance between invocations while handling configuration changes appropriately.

=== TokenValidator Stateful Behavior

The `TokenValidator` maintains important caches:

* JWKS keys from remote endpoints
* Public keys parsed from the JWKS
* Background refresh tasks for key rotation

Creating a new `TokenValidator` for each flowfile would defeat these caching mechanisms and cause:

1. Excessive network traffic to JWKS endpoints
2. Higher latency for token validation
3. Potential rate limiting or blocking from identity providers
4. Increased CPU and memory usage

=== Thread Safety Considerations

Multiple NiFi threads may access the TokenValidator concurrently:

1. Use `volatile` for the TokenValidator instance
2. Synchronize initialization with a lock object
3. Use double-checked locking for efficiency
4. Make configuration change detection thread-safe

=== Resource Management

The TokenValidator uses resources that should be properly managed:

1. HTTP connections for JWKS endpoints
2. Background threads for key rotation
3. Memory for caches

By maintaining a single TokenValidator instance and only recreating it when configuration changes, the processor can benefit from the library's caching while properly managing resources in the NiFi environment.

=== Special NiFi Lifecycle Considerations

NiFi processors have specific lifecycle events that need to be handled:

1. **@OnScheduled**: Perform initialization when the processor is scheduled
2. **@OnStopped**: Clean up resources when the processor is stopped
3. **@OnUnscheduled**: Optional cleanup when the processor is unscheduled

For detailed implementation of this lifecycle management, see link:technical-components.adoc#tokenvalidator-lifecycle-in-nifi[TokenValidator Lifecycle in NiFi].

=== Authorization Checking

While the OAuth-Sheriff library handles basic token validation including issuer, expiration, and audience checks, the processor adds additional authorization checks for specific NiFi use cases:

Authorization checking is implemented in link:../../nifi-cuioss-processors/src/main/java/de/cuioss/nifi/processors/auth/util/AuthorizationValidator.java[AuthorizationValidator], which validates scopes and roles using configurable AND/OR logic with optional case-insensitive matching and explicit bypass support. The processor invokes `AuthorizationValidator.validate()` with an `AuthorizationConfig` and `AccessTokenContent`.

For more information on authorization configuration, see link:configuration.adoc#authorization-configuration[Authorization Configuration].

=== Flow File Attribute Generation

After token validation, the processor extracts token claims and adds them to the flow file's attributes, using a simplified consistent approach:

Flow file attribute generation is implemented in link:../../nifi-cuioss-processors/src/main/java/de/cuioss/nifi/processors/auth/MultiIssuerJWTTokenAuthenticator.java[MultiIssuerJWTTokenAuthenticator] (`onTrigger` method), using attribute key constants from link:../../nifi-cuioss-processors/src/main/java/de/cuioss/nifi/processors/auth/JWTAttributes.java[JWTAttributes].

This approach:

1. Uses a consistent namespace ("jwt.content.") for all token claims
2. Leverages the `getClaims()` method which returns all claims as ClaimValue objects
3. Uses `getOriginalString()` to properly convert all value types to strings
4. Eliminates the need to distinguish between standard and custom claims
5. Simplifies the code significantly while maintaining full functionality

=== Security Event Monitoring

The processor uses the SecurityEventCounter from the OAuth-Sheriff library to track and report security events related to token validation:

* Total tokens processed
* Valid tokens
* Invalid tokens (with breakdowns by error type)
* Processing errors

This counter provides insight into authentication patterns, potential security issues, and operational monitoring.

For comprehensive details on security event monitoring implementation, metrics collection, and integration with monitoring systems, see link:observability.adoc[Observability Specification].

=== Token Verification Interface: Isolated Validation

For the Token Verification Interface (UI token testing), the processor must:

- Reuse the configured IssuerConfig objects from the main processor configuration.
- Create a new SecurityEventCounter for each UI verification request, to capture only the errors relevant to the current test.
- Create a new TokenValidator for each UI verification request, passing in the IssuerConfigs and the new SecurityEventCounter.
- Validate the token using the new TokenValidator instance.
- Return both the validation result and the error details (from the SecurityEventCounter) to the UI.

This ensures that UI-driven token tests do not pollute the main processor's security metrics and provide detailed, isolated error feedback for the user.

UI token verification is implemented in link:../../nifi-cuioss-ui/src/main/java/de/cuioss/nifi/ui/service/JwtValidationService.java[JwtValidationService] (`verifyToken` method), which creates an isolated `TokenValidator` instance per request using the processor's `IssuerConfig` objects.

=== UI REST Integration for Token Verification

The Token Verification Interface in the UI communicates with a backend REST endpoint (e.g., `/api/token/verify`). The backend handler:

- Retrieves the current IssuerConfig objects from the processor configuration.
- Creates a new SecurityEventCounter for this request.
- Instantiates a new TokenValidator with the IssuerConfigs and the new SecurityEventCounter.
- Calls `createAccessToken(tokenString)` on the TokenValidator, catching any TokenValidationException.
- Returns the validation result and error details (from the exception if validation failed) as a JSON response to the UI.

This ensures that each UI verification is isolated, does not affect processor metrics, and provides detailed feedback to the user.

For more details, see the Token Verification Interface section in link:configuration-ui.adoc[UI Configuration].

== Maven Integration

To use the OAuth-Sheriff library in the NiFi processor, add the following dependency to the pom.xml file:

[source,xml]
----
<dependency>
    <groupId>de.cuioss.sheriff.oauth</groupId>
    <artifactId>oauth-sheriff-core</artifactId>
    <version>${version.oauth-sheriff}</version>
</dependency>
----

This will provide access to all the library features needed for token validation.

== Best Practices

Based on the OAuth-Sheriff library recommendations, the processor follows these best practices:

1. Uses the TokenValidator as the main entry point for all token operations
2. Configures IssuerConfig with appropriate validation settings for each issuer
3. Uses ParserConfig to set token size limits and security settings
4. Requires HTTPS for JWKS endpoints in production environments
5. Validates token scopes and roles before granting access to protected resources
6. Sets appropriate refresh intervals for JWKS key rotation
7. Implements proper error handling for token validation failures

For more details on security best practices, see link:security.adoc[Security Considerations].

== See Also

=== Core Documentation
* link:../Specification.adoc[Main Specification]
* link:../Requirements.adoc[Requirements]
* link:../library/oauth-sheriff/Usage.adoc[Library Documentation]

=== Implementation
* link:technical-components.adoc[Technical Components]
* link:configuration.adoc[Configuration]
* link:security.adoc[Security Considerations]
* link:error-handling.adoc[Error Handling]
* link:observability.adoc[Observability]
