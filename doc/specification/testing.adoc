= MultiIssuerJWTTokenAuthenticator Testing
:toc:
:toclevels: 3
:toc-title: Table of Contents
:sectnums:

link:../Specification.adoc[Back to Main Specification]

== Unit Testing
_See Requirement link:../Requirements.adoc#NIFI-AUTH-14[NIFI-AUTH-14: Unit Testing]_

=== Unit Testing JWKS Endpoint Validator
_See Requirement link:../Requirements.adoc#NIFI-AUTH-7.1[NIFI-AUTH-7.1: UI Configuration]_

The JWKS Endpoint Validator can be unit tested using the `cui-test-mockwebserver-junit5` library to simulate HTTP responses. This library provides a simplified way to mock web server responses for testing HTTP clients.

[source,xml]
----
<!-- Dependencies for testing JWKS endpoints -->
<dependency>
    <groupId>de.cuioss.test</groupId>
    <artifactId>cui-test-mockwebserver-junit5</artifactId>
    <version>1.0.0</version>
    <scope>test</scope>
</dependency>
----

[source,java]
----
import de.cuioss.test.mockwebserver.junit5.EnableMockWebServer;
import de.cuioss.test.mockwebserver.junit5.MockWebServerExtension;
import de.cuioss.test.mockwebserver.MockWebServerWrapper;

@EnableMockWebServer
public class JwksEndpointValidatorTest {

    @RegisterExtension
    MockWebServerExtension mockWebServerExtension = new MockWebServerExtension();

    private StandardJwksEndpointValidator validator;
    private MockWebServerWrapper mockWebServer;
    private String baseUrl;

    @BeforeEach
    public void setup() {
        // Get the mock web server from the extension
        mockWebServer = mockWebServerExtension.getMockWebServerWrapper();
        baseUrl = mockWebServer.getBaseUrl();
        
        // Create validator
        validator = new StandardJwksEndpointValidator();
    }

    @Test
    @DisplayName("Validate a properly formatted JWKS endpoint")
    public void testValidJwksEndpoint() {
        // Setup mock response
        String validJwks = "{"
                + "\"keys\": ["
                + "  {"
                + "    \"kty\": \"RSA\","
                + "    \"kid\": \"key1\","
                + "    \"use\": \"sig\","
                + "    \"alg\": \"RS256\","
                + "    \"n\": \"base64-encoded-modulus\","
                + "    \"e\": \"AQAB\""
                + "  }"
                + "]"
                + "}";
        
        mockWebServer.enqueue(validJwks);
        
        // Test validation
        ValidationResult result = validator.validateJwksEndpoint(baseUrl + "/auth/realms/master/protocol/openid-connect/certs");
        
        // Verify result
        assertTrue(result.isValid());
        assertEquals("Successfully connected to JWKS endpoint", result.getExplanation());
        
        // Verify request using the cui-test-mockwebserver API
        mockWebServer.verify()
            .requestTo("/auth/realms/master/protocol/openid-connect/certs")
            .withMethod("GET")
            .called();
    }

    @Test
    @DisplayName("Verify handling of invalid JWKS format")
    public void testInvalidJwksFormat() {
        // Setup mock response with invalid JWKS format
        String invalidJwks = "{ \"not-keys\": [] }";
        
        mockWebServer.enqueue(invalidJwks);
        
        // Test validation
        ValidationResult result = validator.validateJwksEndpoint(baseUrl);
        
        // Verify result
        assertFalse(result.isValid());
        assertEquals("Response is not a valid JWKS format", result.getExplanation());
    }

    @Test
    @DisplayName("Verify handling of HTTP error responses")
    public void testHttpError() {
        // Setup mock response with HTTP error
        mockWebServer.enqueue(404);
        
        // Test validation
        ValidationResult result = validator.validateJwksEndpoint(baseUrl);
        
        // Verify result
        assertFalse(result.isValid());
        assertEquals("Failed to connect to JWKS endpoint: HTTP 404", result.getExplanation());
    }

    @Test
    @DisplayName("Verify handling of connection errors")
    public void testConnectionError() {
        // Test with invalid URL to simulate connection error
        ValidationResult result = validator.validateJwksEndpoint("http://invalid-url.example");
        
        // Verify result
        assertFalse(result.isValid());
        assertTrue(result.getExplanation().startsWith("Error connecting to JWKS endpoint:"));
    }
}
----

=== Unit Testing Token Validation
_See Requirement link:../Requirements.adoc#NIFI-AUTH-3[NIFI-AUTH-3: Token Validation Requirements]_

[source,java]
----
public class JwtTokenValidatorTest {

    private JwtTokenValidator validator;
    private JwksCache mockJwksCache;

    @BeforeEach // Updated from @Before to JUnit 5 annotation
    public void setup() {
        mockJwksCache = mock(JwksCache.class);
        validator = new JwtTokenValidator(mockJwksCache);
    }

    @Test
    @DisplayName("Verify validation of a valid token") // Added DisplayName annotation
    public void testValidToken() throws Exception {
        // Create a valid token
        JWTClaimsSet claimsSet = new JWTClaimsSet.Builder()
                .issuer("test-issuer")
                .subject("test-subject")
                .expirationTime(new Date(System.currentTimeMillis() + 3600000)) // 1 hour in future
                .build();
        
        SignedJWT signedJWT = createSignedJWT(claimsSet);
        ParsedJwtToken token = new ParsedJwtToken.Builder()
                .tokenString(signedJWT.serialize())
                .header(signedJWT.getHeader())
                .claims(claimsSet)
                .build();
        
        // Mock signature verification
        when(mockJwksCache.getJwk(anyString(), anyString())).thenReturn(createMockJWK());
        
        // Test validation
        ValidationResult result = validator.validateToken(token);
        
        // Verify result
        assertTrue(result.isValid());
    }

    @Test
    @DisplayName("Verify rejection of an expired token") // Added DisplayName annotation
    public void testExpiredToken() throws Exception {
        // Create an expired token
        JWTClaimsSet claimsSet = new JWTClaimsSet.Builder()
                .issuer("test-issuer")
                .subject("test-subject")
                .expirationTime(new Date(System.currentTimeMillis() - 3600000)) // 1 hour in past
                .build();
        
        SignedJWT signedJWT = createSignedJWT(claimsSet);
        ParsedJwtToken token = new ParsedJwtToken.Builder()
                .tokenString(signedJWT.serialize())
                .header(signedJWT.getHeader())
                .claims(claimsSet)
                .build();
        
        // Test validation
        ValidationResult result = validator.validateToken(token);
        
        // Verify result
        assertFalse(result.isValid());
        assertEquals("Token has expired", result.getExplanation());
    }

    @Test
    @DisplayName("Verify rejection of tokens with unknown issuers") // Added DisplayName annotation
    public void testUnknownIssuer() throws Exception {
        // Create a token with unknown issuer
        JWTClaimsSet claimsSet = new JWTClaimsSet.Builder()
                .issuer("unknown-issuer")
                .subject("test-subject")
                .expirationTime(new Date(System.currentTimeMillis() + 3600000))
                .build();
        
        SignedJWT signedJWT = createSignedJWT(claimsSet);
        ParsedJwtToken token = new ParsedJwtToken.Builder()
                .tokenString(signedJWT.serialize())
                .header(signedJWT.getHeader())
                .claims(claimsSet)
                .build();
        
        // Test validation
        ValidationResult result = validator.validateToken(token);
        
        // Verify result
        assertFalse(result.isValid());
        assertEquals("Unknown token issuer: unknown-issuer", result.getExplanation());
    }

    private SignedJWT createSignedJWT(JWTClaimsSet claimsSet) throws Exception {
        // Create a signed JWT for testing
        KeyPairGenerator keyGen = KeyPairGenerator.getInstance("RSA");
        keyGen.initialize(2048);
        KeyPair keyPair = keyGen.generateKeyPair();
        
        JWSSigner signer = new RSASSASigner(keyPair.getPrivate());
        
        JWSHeader header = new JWSHeader.Builder(JWSAlgorithm.RS256)
                .keyID("test-key-id")
                .build();
        
        SignedJWT signedJWT = new SignedJWT(header, claimsSet);
        signedJWT.sign(signer);
        
        return signedJWT;
    }

    private JWK createMockJWK() throws Exception {
        // Create a mock JWK for testing
        KeyPairGenerator keyGen = KeyPairGenerator.getInstance("RSA");
        keyGen.initialize(2048);
        KeyPair keyPair = keyGen.generateKeyPair();
        
        return new RSAKey.Builder((RSAPublicKey) keyPair.getPublic())
                .keyID("test-key-id")
                .build();
    }
}
----

== Integration Testing
_See Requirement link:../Requirements.adoc#NIFI-AUTH-15[NIFI-AUTH-15: Integration Testing]_

=== Integration Testing with Real Tokens Using cui-test-keycloak-integration
_See Requirement link:../Requirements.adoc#NIFI-AUTH-3[NIFI-AUTH-3: Token Validation Requirements]_

Integration tests with real tokens can be implemented using the `cui-test-keycloak-integration` library, which provides a robust approach for testing against a real Keycloak instance.

[source,xml]
----
<!-- Dependencies for integration testing with cui-test-keycloak-integration -->
<dependency>
    <groupId>de.cuioss.test</groupId>
    <artifactId>cui-test-keycloak-integration</artifactId>
    <version>1.0.0</version>
    <scope>test</scope>
</dependency>
----

[source,java]
----
import de.cuioss.test.keycloak.junit5.EnableKeycloakIntegration;
import de.cuioss.test.keycloak.configuration.KeycloakConfiguration;
import de.cuioss.test.keycloak.client.KeycloakClient;
import de.cuioss.test.keycloak.KeycloakContainer;

@EnableKeycloakIntegration
@Tag("IntegrationTest")
public class TokenKeycloakITTest {

    private static final Logger LOG = LoggerFactory.getLogger(TokenKeycloakITTest.class);
    
    /**
     * The KeycloakContainer is automatically managed by the cui-test-keycloak-integration
     * library. It's configured through the @KeycloakConfiguration annotation.
     */
    @KeycloakConfiguration(
        realmName = "nifi-test",
        realmConfigFile = "test-realm.json",
        clientId = "nifi-test-client",
        clientSecret = "${client-secret}"
    )
    private KeycloakContainer keycloakContainer;
    
    /**
     * The KeycloakClient provides helper methods for interacting with Keycloak.
     */
    @Inject
    private KeycloakClient keycloakClient;
    
    private TestRunner runner;

    @BeforeEach
    public void setup() {
        // Setup processor
        runner = TestRunners.newTestRunner(MultiIssuerJWTTokenAuthenticator.class);
        runner.setProperty(MultiIssuerJWTTokenAuthenticator.TOKEN_HEADER, "Authorization");
        runner.setProperty(MultiIssuerJWTTokenAuthenticator.JWKS_REFRESH_INTERVAL, "5 min");
        runner.setProperty(MultiIssuerJWTTokenAuthenticator.REQUIRE_VALID_TOKEN, "true");
        runner.setProperty(MultiIssuerJWTTokenAuthenticator.TOKEN_LOCATION, "AUTHORIZATION_HEADER");
        
        // Configure issuer with JWKS URL from the keycloak container
        String jwksUrl = keycloakContainer.getJwksUrl();
        runner.setProperty("nifi-test-issuer", jwksUrl);
        
        LOG.info("Keycloak started at: {}", keycloakContainer.getAuthServerUrl());
        LOG.info("JWKS URL: {}", jwksUrl);
    }

    @Test
    @DisplayName("Verify successful validation of valid tokens")
    public void testValidToken() throws Exception {
        // Get a valid token from Keycloak using the client
        String token = keycloakClient.getAccessToken("test-user", "password");
        
        // Create test flow file
        Map<String, String> attributes = new HashMap<>();
        attributes.put("Authorization", "Bearer " + token);
        runner.enqueue("test data".getBytes(), attributes);
        
        // Run the processor
        runner.run();
        
        // Verify results
        runner.assertAllFlowFilesTransferred(MultiIssuerJWTTokenAuthenticator.SUCCESS, 1);
        
        // Verify attributes
        MockFlowFile resultFlowFile = runner.getFlowFilesForRelationship(
            MultiIssuerJWTTokenAuthenticator.SUCCESS).get(0);
        
        // Verify token attributes
        assertEquals("nifi-test", resultFlowFile.getAttribute("jwt.claims.iss"));
        assertNotNull(resultFlowFile.getAttribute("jwt.subject"));
        assertNotNull(resultFlowFile.getAttribute("jwt.validatedAt"));
        assertEquals("true", resultFlowFile.getAttribute("jwt.authorization.passed"));
    }

    @Test
    @DisplayName("Verify rejection of expired tokens")
    public void testExpiredToken() throws Exception {
        // Get an expired token using the client's helper method
        String token = keycloakClient.getExpiredAccessToken("test-user");
        
        // Create test flow file
        Map<String, String> attributes = new HashMap<>();
        attributes.put("Authorization", "Bearer " + token);
        runner.enqueue("test data".getBytes(), attributes);
        
        // Run the processor
        runner.run();
        
        // Verify results
        runner.assertAllFlowFilesTransferred(MultiIssuerJWTTokenAuthenticator.AUTHENTICATION_FAILED, 1);
        
        // Verify attributes
        MockFlowFile resultFlowFile = runner.getFlowFilesForRelationship(
            MultiIssuerJWTTokenAuthenticator.AUTHENTICATION_FAILED).get(0);
        
        assertEquals("Token has expired", resultFlowFile.getAttribute("jwt.error.reason"));
        assertEquals("AUTH-003", resultFlowFile.getAttribute("jwt.error.code"));
    }
    
    @Test
    @DisplayName("Verify handling of tokens with specific audience")
    public void testTokenWithAudience() throws Exception {
        // Get a token with specific audience
        String token = keycloakClient.getAccessTokenWithAudience("test-user", "password", "specific-audience");
        
        // Configure processor to require this audience
        runner.setProperty(MultiIssuerJWTTokenAuthenticator.REQUIRED_AUDIENCE, "specific-audience");
        
        // Create test flow file
        Map<String, String> attributes = new HashMap<>();
        attributes.put("Authorization", "Bearer " + token);
        runner.enqueue("test data".getBytes(), attributes);
        
        // Run the processor
        runner.run();
        
        // Verify results
        runner.assertAllFlowFilesTransferred(MultiIssuerJWTTokenAuthenticator.SUCCESS, 1);
    }
    
    @Test
    @DisplayName("Verify handling of tokens with specific roles")
    public void testTokenWithRoles() throws Exception {
        // Get a token with specific roles
        String token = keycloakClient.getAccessTokenWithRoles("test-user", "password", Arrays.asList("admin", "user"));
        
        // Configure processor to require the admin role
        runner.setProperty(MultiIssuerJWTTokenAuthenticator.REQUIRED_ROLES, "admin");
        
        // Create test flow file
        Map<String, String> attributes = new HashMap<>();
        attributes.put("Authorization", "Bearer " + token);
        runner.enqueue("test data".getBytes(), attributes);
        
        // Run the processor
        runner.run();
        
        // Verify results
        runner.assertAllFlowFilesTransferred(MultiIssuerJWTTokenAuthenticator.SUCCESS, 1);
    }
}
----

==== Example Implementation from cui-jwt-validation
Here's an example from the cui-jwt-validation project showing how to use the cui-test-keycloak-integration library:

[source,java]
----
/**
 * Integration test for token validation against a real Keycloak instance.
 * Uses the cui-test-keycloak-integration library for simplified testing.
 */
@EnableKeycloakIntegration
@Tag("IntegrationTest")
class TokenKeycloakITTest {

    @KeycloakConfiguration(
        realmName = "cui",
        realmConfigurationFile = "cui/test-realm.json",
        clientId = "vault-api",
        clientSecret = "${client-secret:configure-me}"
    )
    private KeycloakContainer container;

    @Inject
    private KeycloakClient keycloakClient;

    private TokenValidator validator;

    @BeforeEach
    void setUp() {
        // Create a token validator configured with the Keycloak JWKS URL
        IssuerConfig issuerConfig = IssuerConfig.builder()
            .jwksIssuer("cui")
            .jwksEndpoint(container.getJwksUrl())
            .build();

        validator = new TokenValidator(issuerConfig);
    }

    @Test
    void shouldValidateToken() {
        // Get a valid token from Keycloak
        String accessToken = keycloakClient.getAccessToken("test-user", "password");

        // Validate the token
        Optional<AccessTokenContent> optionalToken = validator.createAccessToken(accessToken);

        // Verify token is valid and contains expected claims
        assertTrue(optionalToken.isPresent());
        AccessTokenContent token = optionalToken.get();
        assertEquals("cui", token.getIssuer());
        assertEquals("test-user", token.getPreferredUsername().orElse(null));
        assertFalse(token.isExpired());
    }

    @Test
    void shouldHandleExpiredToken() {
        // Get an expired token
        String expiredToken = keycloakClient.getExpiredAccessToken("test-user");

        // Attempt to validate expired token
        Optional<AccessTokenContent> optionalToken = validator.createAccessToken(expiredToken);
        
        // Token should be parsed but marked as expired
        assertTrue(optionalToken.isPresent());
        AccessTokenContent token = optionalToken.get();
        assertTrue(token.isExpired());
    }

    @Test
    void shouldVerifyAudience() {
        // Get token with specific audience claim
        String token = keycloakClient.getAccessTokenWithAudience("test-user", "password", "expected-audience");
        
        // Create validator that requires specific audience
        TokenValidatorOptions options = TokenValidatorOptions.builder()
            .requireAudience("expected-audience")
            .build();
            
        IssuerConfig issuerConfig = IssuerConfig.builder()
            .jwksIssuer("cui")
            .jwksEndpoint(container.getJwksUrl())
            .build();

        TokenValidator audienceValidator = new TokenValidator(options, issuerConfig);
        
        // Validate the token
        Optional<AccessTokenContent> optionalToken = audienceValidator.createAccessToken(token);
        
        // Token should be valid
        assertTrue(optionalToken.isPresent());
        AccessTokenContent parsedToken = optionalToken.get();
        assertTrue(parsedToken.getAudiences().contains("expected-audience"));
    }
}
----

==== Configuring Test Realm

To configure a test realm for integration testing, create a `test-realm.json` file in your test resources:

[source,json]
----
{
  "realm": "nifi-test",
  "enabled": true,
  "accessTokenLifespan": 60,
  "clients": [
    {
      "clientId": "nifi-test-client",
      "enabled": true,
      "clientAuthenticatorType": "client-secret",
      "secret": "test-secret",
      "redirectUris": ["http://localhost:*"],
      "standardFlowEnabled": true,
      "implicitFlowEnabled": false,
      "directAccessGrantsEnabled": true,
      "serviceAccountsEnabled": true,
      "authorizationServicesEnabled": true,
      "publicClient": false
    }
  ],
  "users": [
    {
      "username": "test-user",
      "email": "test@example.com",
      "enabled": true,
      "credentials": [
        {
          "type": "password",
          "value": "password",
          "temporary": false
        }
      ],
      "realmRoles": ["user"],
      "clientRoles": {
        "nifi-test-client": ["nifi-user", "nifi-admin"]
      }
    }
  ],
  "roles": {
    "realm": [
      {
        "name": "user",
        "description": "User role"
      },
      {
        "name": "admin",
        "description": "Administrator role"
      }
    ],
    "client": {
      "nifi-test-client": [
        {
          "name": "nifi-user",
          "description": "NiFi User"
        },
        {
          "name": "nifi-admin",
          "description": "NiFi Administrator"
        }
      ]
    }
  }
}
----

=== Benefits of using cui-test-keycloak-integration

Using the cui-test-keycloak-integration library provides several advantages:

1. **Automated Lifecycle Management**: The library manages the Keycloak container's lifecycle automatically.

2. **Simple Configuration**: Configure your test realm using a JSON configuration file.

3. **Convenient Helper Methods**: The KeycloakClient API provides simple methods to obtain tokens with different characteristics (expired tokens, tokens with specific roles or audiences, etc.).

4. **Realistic Testing**: Tests against a real Keycloak instance ensure compatibility with actual production environments.

5. **Integration with JUnit 5**: Uses modern testing practices with JUnit 5 extensions and annotations.

By using cui-test-keycloak-integration for integration testing and cui-test-mockwebserver-junit5 for unit testing, you can ensure comprehensive test coverage of your JWT validation components, from individual validators to the full authorization flow.

== See also
* link:security.adoc[Security Specification]
* link:token-validation.adoc[Token Validation]
* link:javascript-testing.adoc[JavaScript Testing]
* link:token-factory-manager.adoc[Token Factory Manager]
* link:../Requirements.adoc[Requirements]
* link:../Specification.adoc[Main Specification]
