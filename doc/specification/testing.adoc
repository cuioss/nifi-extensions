= MultiIssuerJWTTokenAuthenticator Testing
:toc:
:toclevels: 3
:toc-title: Table of Contents
:sectnums:

link:../Specification.adoc[Back to Main Specification]

== Testing Strategy
_See Requirement link:../Requirements.adoc#NIFI-AUTH-12[NIFI-AUTH-12: Testing]_

The MultiIssuerJWTTokenAuthenticator processor is tested through a comprehensive set of tests that cover various aspects of functionality, security, and performance.

=== Testing Layers

The testing strategy includes these layers:

1. **Unit Testing**: Testing individual components in isolation
2. **Integration Testing**: Testing components working together
3. **System Testing**: Testing the processor in a NiFi environment
4. **Security Testing**: Testing security aspects specifically
5. **Performance Testing**: Testing under load and stress conditions

== Unit Testing

=== TokenValidator Testing

Unit tests for the TokenValidator component verify:

1. **Token Parsing**: Correct parsing of various token formats
2. **Signature Validation**: Proper validation of token signatures
3. **Claim Validation**: Proper validation of token claims
4. **Error Handling**: Proper handling of validation errors

[source,java]
----
@Test
void shouldValidateTokenWithCorrectSignature() {
    // Arrange
    String validToken = createValidToken();
    TokenValidator validator = createTokenValidator();
    
    // Act
    Optional<AccessTokenContent> result = validator.createAccessToken(validToken);
    
    // Assert
    assertTrue(result.isPresent(), "Valid token should be accepted");
    assertEquals("test-subject", result.get().getSubject(), "Subject should match");
}

@Test
void shouldRejectTokenWithInvalidSignature() {
    // Arrange
    String invalidToken = createTokenWithInvalidSignature();
    TokenValidator validator = createTokenValidator();
    
    // Act
    Optional<AccessTokenContent> result = validator.createAccessToken(invalidToken);
    
    // Assert
    assertFalse(result.isPresent(), "Invalid signature should be rejected");
}
----

For more details on TokenValidator implementation, see link:token-validation.adoc[Token Validation].

=== Processor Testing

Unit tests for the processor verify:

1. **Property Validation**: Correct validation of processor properties
2. **Token Extraction**: Proper extraction of tokens from different locations
3. **Flow File Routing**: Proper routing of flow files to relationships
4. **Attribute Generation**: Proper generation of output attributes

[source,java]
----
@Test
void testProcessWithValidToken() {
    // Set up processor with mock services
    final TestRunner runner = TestRunners.newTestRunner(MultiIssuerJWTTokenAuthenticator.class);
    
    // Configure processor
    runner.setProperty("Token Location", "AUTHORIZATION_HEADER");
    runner.setProperty("Token Header", "Authorization");
    runner.setProperty("Required Audience", "api://test");
    runner.setProperty("auth-server", "https://auth.example.com/.well-known/jwks.json");
    
    // Mock the TokenValidator
    TokenValidator mockValidator = mock(TokenValidator.class);
    when(mockValidator.createAccessToken(anyString())).thenReturn(Optional.of(createTestToken()));
    
    // Set the mock validator on the processor using reflection
    FieldUtils.writeField(runner.getProcessor(), "tokenValidator", mockValidator, true);
    
    // Create a test flow file with a token
    Map<String, String> attributes = new HashMap<>();
    attributes.put("http.headers.authorization", "Bearer eyJhbGciOiJS..."); 
    runner.enqueue("test data".getBytes(), attributes);
    
    // Run the processor
    runner.run();
    
    // Verify results
    runner.assertAllFlowFilesTransferred(MultiIssuerJWTTokenAuthenticator.SUCCESS, 1);
    
    // Verify output attributes
    MockFlowFile flowFile = runner.getFlowFilesForRelationship(MultiIssuerJWTTokenAuthenticator.SUCCESS).get(0);
    flowFile.assertAttributeExists("jwt.content.sub");
    flowFile.assertAttributeExists("jwt.content.iss");
    flowFile.assertAttributeExists("jwt.validatedAt");
}
----

See link:technical-components.adoc[Technical Components] for processor implementation details.

== Integration Testing

Integration tests verify multiple components working together:

1. **TokenValidator with Real JWTs**: Testing with actual JWT tokens
2. **TokenValidator with JWKS Endpoints**: Testing with mock JWKS endpoints
3. **TokenValidator with Multiple Issuers**: Testing with multiple token issuers

[source,java]
----
@Test
void testProcessorWithMultipleIssuersIntegration() {
    // Set up processor
    final TestRunner runner = TestRunners.newTestRunner(MultiIssuerJWTTokenAuthenticator.class);
    
    // Configure processor with multiple issuers
    runner.setProperty("Token Location", "AUTHORIZATION_HEADER");
    runner.setProperty("Token Header", "Authorization");
    runner.setProperty("issuer1", getTestJwksUrl("/jwks1.json"));
    runner.setProperty("issuer2", getTestJwksUrl("/jwks2.json"));
    
    // Set up mock JWKS endpoints with WireMock
    // ... (WireMock setup code)
    
    // Create test flow files with tokens from different issuers
    createFlowFileWithToken(runner, createToken("issuer1"));
    
    // Run the processor
    runner.run(2); // Process 2 flow files
    
    // Verify results
    runner.assertAllFlowFilesTransferred(MultiIssuerJWTTokenAuthenticator.SUCCESS, 2);
}
----

For more details on integration patterns, see link:integration-patterns.adoc[Integration Patterns].

== System Testing

System tests verify the processor in a real NiFi environment:

1. **Deployment Testing**: Testing deployment in a NiFi instance
2. **Configuration Testing**: Testing configuration through the UI
3. **Flow Testing**: Testing in a complete flow with other processors

For more details on system testing approach, see link:configuration-ui.adoc[UI Configuration].

== Security Testing

Security tests focus on security aspects of the processor:

1. **Token Attack Testing**: Testing with malformed or malicious tokens
2. **Algorithm Attack Testing**: Testing with weak or forbidden algorithms
3. **Resource Attack Testing**: Testing with very large tokens or high request rates
4. **JWKS Security Testing**: Testing JWKS endpoint security

[source,java]
----
@Test
void testTokenSizeLimit() {
    // Set up processor
    final TestRunner runner = TestRunners.newTestRunner(MultiIssuerJWTTokenAuthenticator.class);
    
    // Configure processor with a small token size limit
    runner.setProperty("Token Location", "AUTHORIZATION_HEADER");
    runner.setProperty("Maximum Token Size", "100");
    runner.setProperty("auth-server", getTestJwksUrl());
    
    // Create a flow file with a token exceeding the size limit
    String oversizedToken = "Bearer " + generateOversizedToken(200); // Generate token > 100 bytes
    Map<String, String> attributes = new HashMap<>();
    attributes.put("http.headers.authorization", oversizedToken);
    runner.enqueue("test data".getBytes(), attributes);
    
    // Run the processor
    runner.run();
    
    // Verify the token was rejected due to size
    runner.assertAllFlowFilesTransferred(MultiIssuerJWTTokenAuthenticator.AUTHENTICATION_FAILED, 1);
    MockFlowFile flowFile = runner.getFlowFilesForRelationship(MultiIssuerJWTTokenAuthenticator.AUTHENTICATION_FAILED).get(0);
    flowFile.assertAttributeExists("jwt.error.reason");
    flowFile.assertAttributeEquals("jwt.error.code", "AUTH-001");
}
----

For more details on security considerations, see link:security.adoc[Security].

== Performance Testing

Performance tests verify the processor under load:

1. **Throughput Testing**: Testing with high flow file rates
2. **Token Size Testing**: Testing with various token sizes
3. **Concurrent Processing Testing**: Testing with multiple threads
4. **Cache Performance Testing**: Testing JWKS caching efficiency

[source,java]
----
@Test
void testHighThroughputPerformance() {
    // Set up processor
    final TestRunner runner = TestRunners.newTestRunner(MultiIssuerJWTTokenAuthenticator.class);
    
    // Configure processor
    runner.setProperty("Token Location", "AUTHORIZATION_HEADER");
    runner.setProperty("auth-server", getTestJwksUrl());
    
    // Create many flow files with tokens
    for (int i = 0; i < 1000; i++) {
        Map<String, String> attributes = new HashMap<>();
        attributes.put("http.headers.authorization", "Bearer " + createTestToken());
        runner.enqueue("test data".getBytes(), attributes);
    }
    
    // Run the processor with timing
    long startTime = System.currentTimeMillis();
    runner.run(1000);
    long endTime = System.currentTimeMillis();
    
    // Verify throughput
    runner.assertAllFlowFilesTransferred(MultiIssuerJWTTokenAuthenticator.SUCCESS, 1000);
    
    // Calculate and log throughput
    long duration = endTime - startTime;
    double throughputPerSecond = (1000.0 / duration) * 1000;
    System.out.println("Throughput: " + throughputPerSecond + " tokens/second");
    
    // Assert minimum throughput requirement
    assertTrue(throughputPerSecond > 100, "Throughput should exceed 100 tokens/second");
}
----

== Test Data Generation

=== JWT Token Generation

Test JWT tokens are generated with various characteristics for testing:

[source,java]
----
private String createTestToken() {
    return JWT.create()
        .withSubject("test-subject")
        .withIssuer("test-issuer")
        .withAudience("api://test")
        .withClaim("scope", "read write")
        .withExpiresAt(Date.from(Instant.now().plusSeconds(3600)))
        .sign(algorithm);
}

private String createExpiredToken() {
    return JWT.create()
        .withSubject("test-subject")
        .withIssuer("test-issuer")
        .withAudience("api://test")
        .withExpiresAt(Date.from(Instant.now().minusSeconds(3600)))
        .sign(algorithm);
}
----

=== JWKS Endpoint Simulation

Test JWKS endpoints are simulated for testing:

[source,java]
----
private void setupMockJwksEndpoint(WireMockServer wireMockServer, String path, RSAPublicKey publicKey) {
    JWK jwk = new RSAKey.Builder(publicKey)
        .keyID("test-key-id")
        .algorithm(JWSAlgorithm.RS256)
        .build();
    
    JWKSet jwkSet = new JWKSet(jwk);
    String jwksJson = jwkSet.toString();
    
    wireMockServer.stubFor(get(urlEqualTo(path))
        .willReturn(aResponse()
            .withHeader("Content-Type", "application/json")
            .withBody(jwksJson)));
}
----

== Test Coverage

The test suite aims for high coverage across all areas:

1. **Line Coverage**: >90% line coverage for core components
2. **Branch Coverage**: >85% branch coverage for decision points
3. **Method Coverage**: >95% method coverage

Test coverage is measured and reported during the build process.

== Test Execution

Tests are run automatically as part of the build process:

1. **Unit Tests**: Run during `mvn test`
2. **Integration Tests**: Run during `mvn verify`
3. **Performance Tests**: Run manually or on demand

== See Also

* link:token-validation.adoc[Token Validation]
* link:configuration.adoc[Configuration]
* link:security.adoc[Security]
* link:technical-components.adoc[Technical Components]
* link:javascript-testing.adoc[JavaScript Testing]
* link:../Requirements.adoc#NIFI-AUTH-12[Testing Requirements]
* link:../Specification.adoc[Back to Main Specification]
