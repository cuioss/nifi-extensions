= MultiIssuerJWTTokenAuthenticator Configuration
:toc:
:toclevels: 3
:toc-title: Table of Contents
:sectnums:

link:../Specification.adoc[Back to Main Specification]

== Configuration Properties
_See Requirement link:../Requirements.adoc#NIFI-AUTH-7[NIFI-AUTH-7: Configuration Requirements]_

=== Static Properties
_See Requirement link:../Requirements.adoc#NIFI-AUTH-5.3[NIFI-AUTH-5.3: Advanced Properties]_

The following properties are configured as advanced properties and are only shown when the user clicks the "Advanced" button in the processor configuration dialog.

[cols="2,1,1,2"]
|===
|Property |Type |Default |Description

|Token Header Name
|String
|Authorization
|Name of the header containing the JWT token

|JWKS Refresh Interval
|Time Period
|15 minutes
|How often to refresh the JWKS cache

|Require Valid Token
|Boolean
|true
|When true, only valid tokens result in success relationship

|Token Location
|String
|AUTHORIZATION_HEADER
|Where to find the token (AUTHORIZATION_HEADER, CUSTOM_HEADER, FLOW_FILE_CONTENT)

|Custom Header Name
|String
|null
|Name of custom header when Token Location is set to CUSTOM_HEADER
|===

=== Static Configuration for Container Environments
_See Requirement link:../Requirements.adoc#NIFI-AUTH-7.7[NIFI-AUTH-7.7: Static Configuration for Container Environments]_

In container environments, it is often preferred to use static configuration rather than configuring processors through the UI. The MultiIssuerJWTTokenAuthenticator processor supports static configuration through various file formats.

==== Configuration File Formats

The following file formats are supported for static configuration:

[cols="2,4"]
|===
|Format |Description

|NiFi Properties (.properties)
|Standard Java properties format used by NiFi

|YAML Configuration (.yml, .yaml)
|YAML format for more structured configuration

|JSON Configuration (.json)
|JSON format for structured configuration
|===

==== Configuration Behavior

The static configuration has the following behavior:

[cols="2,4"]
|===
|Behavior |Description

|Active by Default
|When a valid configuration file is present, it will be loaded and used automatically without requiring additional activation steps

|UI Display
|The static configuration values will be displayed in the processor configuration dialog for transparency

|Read-Only in UI
|Static configuration values displayed in the UI cannot be edited through the UI, ensuring consistency with the file-based configuration

|Configuration Precedence
|Static configuration takes precedence over UI-configured values
|===

==== Configuration File Locations

The processor will look for configuration files in the following locations (in order of precedence):

1. Path specified by `jwt.config.path` JVM system property
2. Path specified by `JWT_CONFIG_PATH` environment variable
3. `conf/jwt-validation.properties`, `conf/jwt-validation.yml`, or `conf/jwt-validation.json` in the NiFi installation directory

==== Configuration Properties

The static configuration file supports all properties available through the UI:

[cols="2,1,1,2"]
|===
|Property |Format |Default |Description

|issuers
|List
|Empty
|List of JWT issuers to trust

|issuers.<name>.jwksUrl
|URL
|null
|JWKS endpoint URL for the issuer

|issuers.<name>.publicKey
|String
|null
|PEM-encoded public key for the issuer

|tokenHeaderName
|String
|Authorization
|Name of the header containing the JWT token

|jwksRefreshInterval
|Duration
|15 minutes
|How often to refresh the JWKS cache

|requireValidToken
|Boolean
|true
|When true, only valid tokens result in success relationship

|tokenLocation
|String
|AUTHORIZATION_HEADER
|Where to find the token (AUTHORIZATION_HEADER, CUSTOM_HEADER, FLOW_FILE_CONTENT)

|customHeaderName
|String
|null
|Name of custom header when Token Location is set to CUSTOM_HEADER
|===

==== Sample Configuration Files

*Properties File Format:*

[source,properties]
----
# JWT Authenticator Configuration
tokenHeaderName=Authorization
jwksRefreshInterval=15 minutes
requireValidToken=true
tokenLocation=AUTHORIZATION_HEADER

# Issuer configurations
issuers.google.jwksUrl=https://www.googleapis.com/oauth2/v3/certs
issuers.internal.publicKey=-----BEGIN PUBLIC KEY-----\nMIIB...AQAB\n-----END PUBLIC KEY-----
----

*YAML Format:*

[source,yaml]
----
# JWT Authenticator Configuration
tokenHeaderName: Authorization
jwksRefreshInterval: "15 minutes"
requireValidToken: true
tokenLocation: AUTHORIZATION_HEADER

# Issuer configurations
issuers:
  google:
    jwksUrl: https://www.googleapis.com/oauth2/v3/certs
  internal:
    publicKey: |
      -----BEGIN PUBLIC KEY-----
      MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA...
      -----END PUBLIC KEY-----
----

*JSON Format:*

[source,json]
----
{
  "tokenHeaderName": "Authorization",
  "jwksRefreshInterval": "15 minutes",
  "requireValidToken": true,
  "tokenLocation": "AUTHORIZATION_HEADER",
  "issuers": {
    "google": {
      "jwksUrl": "https://www.googleapis.com/oauth2/v3/certs"
    },
    "internal": {
      "publicKey": "-----BEGIN PUBLIC KEY-----\nMIIB...AQAB\n-----END PUBLIC KEY-----"
    }
  }
}
----

==== Configuration Precedence 

When both static configuration and UI configuration are present:

1. Static configuration takes precedence over UI configuration
2. Properties defined in the static configuration override corresponding UI settings
3. Properties not defined in the static configuration retain their UI-configured values

==== Configuration Display in UI

When static configuration is active:

1. The UI displays all configuration values from the static configuration
2. UI fields for static-configured properties are shown as read-only
3. A visual indicator shows which properties are from static configuration
4. A timestamp shows when the static configuration was last loaded

==== Configuration Reloading

The processor supports automatic reloading of static configuration:

1. Configuration files are checked periodically for changes (default: 5 minutes)
2. The reload interval is configurable via `jwt.auth.config.reload.interval` system property
3. Changes to static configuration are logged at INFO level
4. Configuration reloads without requiring a processor restart
5. If the new configuration is invalid, the processor retains the previous valid configuration

==== Implementation for Container Environments

For container environments, the recommended approach is:

1. Mount a configuration file into the container at a known location
2. Set the `JWT_AUTH_CONFIG_FILE` environment variable to point to this location
3. Use YAML or JSON format for better readability and structure
4. Include all required issuer configurations in the static file
5. For Kubernetes deployments, use ConfigMaps or Secrets to manage the configuration

==== Environment Variable Configuration
_See Requirement link:../Requirements.adoc#NIFI-AUTH-7.7[NIFI-AUTH-7.7: Static Configuration for Container Environments]_

For container environments, configuration can also be provided through environment variables:

[cols="2,1,3"]
|===
|Environment Variable |Type |Description

|JWT_TOKEN_HEADER_NAME
|String
|Name of the header containing the JWT token

|JWT_JWKS_REFRESH_INTERVAL
|Duration
|How often to refresh the JWKS cache (format: "15 minutes", "1 hour", etc.)

|JWT_REQUIRE_VALID_TOKEN
|Boolean
|When true, only valid tokens result in success relationship

|JWT_TOKEN_LOCATION
|String
|Where to find the token (AUTHORIZATION_HEADER, CUSTOM_HEADER, FLOW_FILE_CONTENT)

|JWT_CUSTOM_HEADER_NAME
|String
|Name of custom header when Token Location is set to CUSTOM_HEADER

|JWT_ISSUER_{name}_JWKS_URL
|URL
|JWKS endpoint URL for the issuer with name {name}

|JWT_ISSUER_{name}_PUBLIC_KEY
|String
|PEM-encoded public key for the issuer with name {name}
|===

==== Environment Variable Examples

[source,bash]
----
# Basic configuration
export JWT_TOKEN_HEADER_NAME=Authorization
export JWT_JWKS_REFRESH_INTERVAL="30 minutes"
export JWT_REQUIRE_VALID_TOKEN=true
export JWT_TOKEN_LOCATION=AUTHORIZATION_HEADER

# Issuer configurations
export JWT_ISSUER_GOOGLE_JWKS_URL=https://www.googleapis.com/oauth2/v3/certs
export JWT_ISSUER_INTERNAL_PUBLIC_KEY="-----BEGIN PUBLIC KEY-----\nMIIB...AQAB\n-----END PUBLIC KEY-----"
----

==== Environment Variable Precedence

The configuration precedence order is:
1. Static configuration files
2. Environment variables
3. UI configuration

When environment variables are used in combination with static configuration files:
1. Properties defined in static configuration files override corresponding environment variables
2. Environment variables override UI settings for properties not defined in static files

==== Container Orchestration Support

For Kubernetes and other container orchestration platforms:

[source,yaml]
----
apiVersion: v1
kind: ConfigMap
metadata:
  name: jwt-auth-config
data:
  JWT_TOKEN_HEADER_NAME: "Authorization"
  JWT_JWKS_REFRESH_INTERVAL: "30 minutes"
  JWT_REQUIRE_VALID_TOKEN: "true"
  JWT_TOKEN_LOCATION: "AUTHORIZATION_HEADER"
  JWT_ISSUER_GOOGLE_JWKS_URL: "https://www.googleapis.com/oauth2/v3/certs"
---
apiVersion: v1
kind: Secret
metadata:
  name: jwt-auth-secrets
type: Opaque
stringData:
  JWT_ISSUER_INTERNAL_PUBLIC_KEY: |
    -----BEGIN PUBLIC KEY-----
    MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA...
    -----END PUBLIC KEY-----
----

==== Implementation for Environment Variables

The processor loads configuration from environment variables during initialization:

[source,java]
----
private void loadEnvironmentVariables() {
    Map<String, String> envVars = System.getenv();
    
    // Load basic configuration
    String tokenHeader = envVars.get("JWT_TOKEN_HEADER_NAME");
    if (tokenHeader != null) {
        config.setTokenHeaderName(tokenHeader);
    }
    
    String refreshInterval = envVars.get("JWT_JWKS_REFRESH_INTERVAL");
    if (refreshInterval != null) {
        config.setJwksRefreshInterval(TimeUtil.parseDuration(refreshInterval));
    }
    
    String requireValidToken = envVars.get("JWT_REQUIRE_VALID_TOKEN");
    if (requireValidToken != null) {
        config.setRequireValidToken(Boolean.parseBoolean(requireValidToken));
    }
    
    String tokenLocation = envVars.get("JWT_TOKEN_LOCATION");
    if (tokenLocation != null) {
        config.setTokenLocation(TokenLocation.valueOf(tokenLocation));
    }
    
    String customHeaderName = envVars.get("JWT_CUSTOM_HEADER_NAME");
    if (customHeaderName != null) {
        config.setCustomHeaderName(customHeaderName);
    }
    
    // Load issuer configurations
    Map<String, IssuerConfig> issuers = new HashMap<>();
    
    for (Map.Entry<String, String> entry : envVars.entrySet()) {
        String key = entry.getKey();
        String value = entry.getValue();
        
        if (key.startsWith("JWT_ISSUER_") && key.endsWith("_JWKS_URL")) {
            // Extract issuer name from environment variable
            String issuerName = key.substring("JWT_ISSUER_".length(), 
                                            key.length() - "_JWKS_URL".length())
                                .toLowerCase();
            
            IssuerConfig issuerConfig = issuers.getOrDefault(issuerName, new IssuerConfig());
            issuerConfig.setJwksUrl(value);
            issuers.put(issuerName, issuerConfig);
        } else if (key.startsWith("JWT_ISSUER_") && key.endsWith("_PUBLIC_KEY")) {
            // Extract issuer name from environment variable
            String issuerName = key.substring("JWT_ISSUER_".length(),
                                            key.length() - "_PUBLIC_KEY".length())
                                .toLowerCase();
            
            IssuerConfig issuerConfig = issuers.getOrDefault(issuerName, new IssuerConfig());
            issuerConfig.setPublicKey(value);
            issuers.put(issuerName, issuerConfig);
        }
    }
    
    // Add issuers to configuration
    for (Map.Entry<String, IssuerConfig> entry : issuers.entrySet()) {
        config.addIssuer(entry.getKey(), entry.getValue());
    }
}
----

==== Security Considerations for Static Configuration

When using static configuration:

1. Ensure configuration files have appropriate access controls
2. Do not store sensitive keys in plain text in the configuration file
3. For production environments, use external secret management systems
4. Consider using environment variables for sensitive values in the configuration
5. When using issuer public keys, ensure they are properly formatted and secure

==== UI Implementation for Static Configuration

When static configuration is active:

[source,java]
----
@Override
public void onTrigger(final ProcessContext context, final ProcessSession session) throws ProcessException {
    // Check if static configuration is active
    if (staticConfigurationManager.isStaticConfigurationActive()) {
        // Log that static configuration is being used
        if (logger.isDebugEnabled()) {
            logger.debug("Using static configuration from: {}", 
                staticConfigurationManager.getConfigurationSource());
        }
        
        // Use the static configuration
        JWTProcessorConfig config = staticConfigurationManager.getProcessorConfig();
        
        // Process with static configuration
        processWithConfiguration(context, session, config);
    } else {
        // Use UI-configured settings
        processWithUIConfiguration(context, session);
    }
}
----
==== Implementation of Advanced Properties
_See Requirement link:../Requirements.adoc#NIFI-AUTH-5.3[NIFI-AUTH-5.3: Advanced Properties]_

The advanced properties are implemented using the `isAdvanced` method in NiFi 2.3.0:

[source,java]
----
// Property Descriptors for NiFi 2.3.0
public static final PropertyDescriptor TOKEN_HEADER = new PropertyDescriptor.Builder()
    .name("Token Header Name")
    .displayName("Token Header Name")
    .description(i18nResolver.getTranslatedString("property.token.header.description"))
    .required(true)
    .defaultValue("Authorization")
    .addValidator(StandardValidators.NON_EMPTY_VALIDATOR)
    .expressionLanguageSupported(ExpressionLanguageScope.NONE)
    .build();

public static final PropertyDescriptor JWKS_REFRESH_INTERVAL = new PropertyDescriptor.Builder()
    .name("JWKS Refresh Interval")
    .displayName("JWKS Refresh Interval")
    .description(i18nResolver.getTranslatedString("property.jwks.refresh.description"))
    .required(true)
    .defaultValue("15 min")
    .addValidator(StandardValidators.TIME_PERIOD_VALIDATOR)
    .expressionLanguageSupported(ExpressionLanguageScope.NONE)
    .build();

public static final PropertyDescriptor REQUIRE_VALID_TOKEN = new PropertyDescriptor.Builder()
    .name("Require Valid Token")
    .displayName("Require Valid Token")
    .description(i18nResolver.getTranslatedString("property.require.valid.token.description"))
    .required(true)
    .defaultValue("true")
    .allowableValues("true", "false")
    .addValidator(StandardValidators.BOOLEAN_VALIDATOR)
    .expressionLanguageSupported(ExpressionLanguageScope.NONE)
    .build();

public static final PropertyDescriptor TOKEN_LOCATION = new PropertyDescriptor.Builder()
    .name("Token Location")
    .displayName("Token Location")
    .description(i18nResolver.getTranslatedString("property.token.location.description"))
    .required(true)
    .defaultValue("AUTHORIZATION_HEADER")
    .allowableValues("AUTHORIZATION_HEADER", "CUSTOM_HEADER", "FLOW_FILE_CONTENT")
    .addValidator(StandardValidators.NON_EMPTY_VALIDATOR)
    .expressionLanguageSupported(ExpressionLanguageScope.NONE)
    .dependsOn(REQUIRE_VALID_TOKEN, "true")
    .build();

public static final PropertyDescriptor CUSTOM_HEADER_NAME = new PropertyDescriptor.Builder()
    .name("Custom Header Name")
    .displayName("Custom Header Name")
    .description(i18nResolver.getTranslatedString("property.custom.header.name.description"))
    .required(false)
    .addValidator(StandardValidators.NON_EMPTY_VALIDATOR)
    .expressionLanguageSupported(ExpressionLanguageScope.NONE)
    .dependsOn(TOKEN_LOCATION, "CUSTOM_HEADER")
    .build();

@Override
protected List<PropertyDescriptor> getSupportedPropertyDescriptors() {
    final List<PropertyDescriptor> properties = new ArrayList<>();
    properties.add(TOKEN_HEADER);
    properties.add(JWKS_REFRESH_INTERVAL);
    properties.add(REQUIRE_VALID_TOKEN);
    properties.add(TOKEN_LOCATION);
    properties.add(CUSTOM_HEADER_NAME);
    return properties;
}

@Override
protected PropertyDescriptor getSupportedDynamicPropertyDescriptor(final String propertyDescriptorName) {
    return new PropertyDescriptor.Builder()
        .name(propertyDescriptorName)
        .displayName(propertyDescriptorName)
        .description(i18nResolver.getTranslatedString("property.issuer.description"))
        .required(false)
        .dynamic(true)
        .addValidator(new JwksEndpointValidator())
        .expressionLanguageSupported(ExpressionLanguageScope.NONE)
        .build();
}

@Override
public boolean isAdvanced(PropertyDescriptor property) {
    return TOKEN_HEADER.equals(property) || 
           JWKS_REFRESH_INTERVAL.equals(property) || 
           REQUIRE_VALID_TOKEN.equals(property) ||
           TOKEN_LOCATION.equals(property) ||
           CUSTOM_HEADER_NAME.equals(property);
}
----

=== Dynamic Properties
_See Requirement link:../Requirements.adoc#NIFI-AUTH-5.2[NIFI-AUTH-5.2: Dynamic Properties]_

Dynamic properties are used to configure token issuers. Each property represents a single issuer configuration. In NiFi 2.3.0, these are validated using custom validators.

[cols="2,1,2"]
|===
|Property |Type |Description

|Issuer Identifier
|String
|Value can be either a JWKS URL or a PEM-encoded public key
|===

==== Custom Validator for JWKS Endpoints

NiFi 2.3.0 supports custom validators for property values:

[source,java]
----
public class JwksEndpointValidator implements Validator {
    @Override
    public ValidationResult validate(String subject, String input, ValidationContext context) {
        if (MoreStrings.isBlank(input)) {
            return new ValidationResult.Builder()
                .input(input)
                .subject(subject)
                .valid(false)
                .explanation("Value cannot be empty")
                .build();
        }
        
        // Check if the input is a URL
        if (input.startsWith("http://") || input.startsWith("https://")) {
            // Validate JWKS URL
            try {
                URL url = new URL(input);
                
                // Check for HTTPS
                if (!"https".equalsIgnoreCase(url.getProtocol())) {
                    return new ValidationResult.Builder()
                        .input(input)
                        .subject(subject)
                        .valid(false)
                        .explanation("JWKS URL must use HTTPS for security")
                        .build();
                }
                
                return new ValidationResult.Builder()
                    .input(input)
                    .subject(subject)
                    .valid(true)
                    .build();
            } catch (MalformedURLException e) {
                return new ValidationResult.Builder()
                    .input(input)
                    .subject(subject)
                    .valid(false)
                    .explanation("Invalid URL format: " + e.getMessage())
                    .build();
            }
        } else {
            // Validate as PEM-encoded public key
            try {
                // Check if input starts with PEM header
                if (!input.startsWith("-----BEGIN")) {
                    return new ValidationResult.Builder()
                        .input(input)
                        .subject(subject)
                        .valid(false)
                        .explanation("Invalid public key format. Must be PEM-encoded")
                        .build();
                }
                
                // Basic PEM validation (detailed validation happens at runtime)
                if (!input.contains("-----BEGIN PUBLIC KEY-----") || !input.contains("-----END PUBLIC KEY-----")) {
                    return new ValidationResult.Builder()
                        .input(input)
                        .subject(subject)
                        .valid(false)
                        .explanation("Invalid PEM format for public key")
                        .build();
                }
                
                return new ValidationResult.Builder()
                    .input(input)
                    .subject(subject)
                    .valid(true)
                    .build();
            } catch (Exception e) {
                return new ValidationResult.Builder()
                    .input(input)
                    .subject(subject)
                    .valid(false)
                    .explanation("Invalid public key: " + e.getMessage())
                    .build();
            }
        }
    }
}
----

== UI Configuration
_See Requirement link:../Requirements.adoc#NIFI-AUTH-7.1[NIFI-AUTH-7.1: UI Configuration]_

NiFi 2.3.0 supports enhanced UI capabilities for processors.

=== Internationalized Property Descriptors
_See Requirement link:../Requirements.adoc#NIFI-AUTH-17[NIFI-AUTH-17: Internationalization Support]_

The processor uses internationalized strings for all UI elements through the i18nResolver API:

[source,java]
----
// Configure internationalization in NiFi 2.3.0
@Override
protected void init(final ProcessorInitializationContext context) {
    i18nResolver = NiFiI18nResolver.createDefault(context.getLogger());
}

public static final PropertyDescriptor TOKEN_HEADER = new PropertyDescriptor.Builder()
    .name("Token Header Name")
    .displayName(i18nResolver.getTranslatedString("property.token.header.name"))
    .description(i18nResolver.getTranslatedString("property.token.header.description"))
    .required(true)
    .defaultValue("Authorization")
    .addValidator(StandardValidators.NON_EMPTY_VALIDATOR)
    .build();

public static final PropertyDescriptor JWKS_REFRESH_INTERVAL = new PropertyDescriptor.Builder()
    .name("JWKS Refresh Interval")
    .displayName(i18nResolver.getTranslatedString("property.jwks.refresh.interval.name"))
    .description(i18nResolver.getTranslatedString("property.jwks.refresh.interval.description"))
    .required(true)
    .defaultValue("15 min")
    .addValidator(StandardValidators.TIME_PERIOD_VALIDATOR)
    .build();

public static final PropertyDescriptor REQUIRE_VALID_TOKEN = new PropertyDescriptor.Builder()
    .name("Require Valid Token")
    .displayName(i18nResolver.getTranslatedString("property.require.valid.token.name"))
    .description(i18nResolver.getTranslatedString("property.require.valid.token.description"))
    .required(true)
    .defaultValue("true")
    .allowableValues("true", "false")
    .build();

@Override
protected List<PropertyDescriptor> getSupportedPropertyDescriptors() {
    final List<PropertyDescriptor> properties = new ArrayList<>();
    properties.add(TOKEN_HEADER);
    properties.add(JWKS_REFRESH_INTERVAL);
    properties.add(REQUIRE_VALID_TOKEN);
    return properties;
}

@Override
protected PropertyDescriptor getSupportedDynamicPropertyDescriptor(final String propertyDescriptorName) {
    return new PropertyDescriptor.Builder()
        .name(propertyDescriptorName)
        .displayName(i18nResolver.getTranslatedString("property.issuer.name", propertyDescriptorName))
        .description(i18nResolver.getTranslatedString("property.issuer.description", propertyDescriptorName))
        .required(true)
        .dynamic(true)
        .addValidator(new JwksEndpointValidator())
        .build();
}
----

=== Custom UI Components in NiFi 2.3.0

==== JWKS Endpoint Test Button
_See Requirement link:../Requirements.adoc#NIFI-AUTH-7.1[NIFI-AUTH-7.1: UI Configuration]_

The JWKS Endpoint Test Button uses NiFi 2.3.0's improved custom UI capabilities:

[source,javascript]
----
// UI Extension for JWKS Test Button using NiFi 2.3.0 API
define(['jquery', 'nf.Common'], function ($, nfCommon) {
    return {
        /**
         * Initialize the custom UI.
         */
        init: function (element, propertyValue, callback) {
            // Get i18n resources from NiFi Common
            var i18n = nfCommon.getI18n();
            
            // Create UI elements
            var container = $('<div class="jwks-verification-container"></div>');
            var verifyButton = $('<button type="button" class="verify-jwks-button">' + i18n['processor.jwt.testConnection'] + '</button>');
            var resultContainer = $('<div class="verification-result"></div>');
            
            // Add elements to the DOM
            container.append(verifyButton).append(resultContainer);
            $(element).append(container);
            
            // Handle button click
            verifyButton.on('click', function () {
                var jwksUrl = propertyValue;
                if (jwksUrl && jwksUrl.startsWith('http')) {
                    resultContainer.html('<span class="fa fa-spinner fa-spin"></span>');
                    
                    // Make AJAX request to verify JWKS URL using NiFi 2.3.0 API
                    $.ajax({
                        type: 'POST',
                        url: '../nifi-api/processors/verify-jwks',
                        data: JSON.stringify({
                            jwksUrl: jwksUrl
                        }),
                        contentType: 'application/json',
                        dataType: 'json'
                    }).done(function (response) {
                        if (response.valid) {
                            resultContainer.html('<span class="fa fa-check" style="color: green;"></span> ' + 
                                                i18n['processor.jwt.connectionSuccessful']);
                        } else {
                            resultContainer.html('<span class="fa fa-times" style="color: red;"></span> ' + 
                                                i18n['processor.jwt.connectionFailed'] + response.explanation);
                        }
                    }).fail(function (xhr) {
                        resultContainer.html('<span class="fa fa-times" style="color: red;"></span> ' + 
                                            i18n['processor.jwt.testFailed'] + xhr.responseText);
                    });
                } else {
                    resultContainer.html('<span class="fa fa-times" style="color: red;"></span> ' + 
                                        i18n['processor.jwt.notValidUrl']);
                }
            });
            
            callback({
                validate: function () {
                    return true;
                },
                getValue: function () {
                    return propertyValue;
                },
                setValue: function (newValue) {
                    propertyValue = newValue;
                }
            });
        },
        
        /**
         * Clean up any resources before the element is removed from the DOM.
         */
        cleanup: function (element) {
            $(element).find('.verify-jwks-button').off();
        }
    };
}
----

==== Token Verification Interface
_See Requirement link:../Requirements.adoc#NIFI-AUTH-7.3[NIFI-AUTH-7.3: Verification]_

The Token Verification Interface in NiFi 2.3.0:

[source,javascript]
----
// Token verification UI using NiFi 2.3.0 API
define(['jquery', 'nf.Common'], function ($, nfCommon) {
    return {
        /**
         * Initialize the custom UI.
         */
        init: function (element, processorId, callback) {
            // Get i18n resources from NiFi Common
            var i18n = nfCommon.getI18n();
            
            // Create UI elements
            var container = $('<div class="token-verification-container"></div>');
            var tokenInput = $('<textarea class="token-input" placeholder="' + i18n['processor.jwt.tokenPlaceholder'] + '"></textarea>');
            var verifyButton = $('<button type="button" class="verify-token-button">' + i18n['processor.jwt.verifyButton'] + '</button>');
            var resultContainer = $('<div class="verification-result"></div>');
            
            // Add elements to the DOM
            container.append(tokenInput)
                    .append(verifyButton)
                    .append(resultContainer);
            $(element).append(container);
            
            // Handle button click
            verifyButton.on('click', function () {
                var token = tokenInput.val().trim();
                if (!token) {
                    resultContainer.html('<div class="message-warning">' + i18n['processor.jwt.enterToken'] + '</div>');
                    return;
                }
                
                resultContainer.html('<span class="fa fa-spinner fa-spin"></span> ' + i18n['processor.jwt.verifyingToken']);
                
                // Make AJAX request to verify the token using NiFi 2.3.0 API
                $.ajax({
                    type: 'POST',
                    url: '../nifi-api/processors/' + processorId + '/verify-token',
                    data: JSON.stringify({
                        token: token
                    }),
                    contentType: 'application/json',
                    dataType: 'json'
                }).done(function (response) {
                    if (response.valid) {
                        // Show success message with token details
                        var html = '<div class="message-success">' + i18n['processor.jwt.tokenValid'] + '</div>';
                        html += '<div class="token-details">';
                        html += '<h4>' + i18n['processor.jwt.tokenDetails'] + '</h4>';
                        html += '<table class="token-info-table">';
                        html += '<tr><td>' + i18n['processor.jwt.issuer'] + '</td><td>' + response.issuer + '</td></tr>';
                        html += '<tr><td>' + i18n['processor.jwt.subject'] + '</td><td>' + response.subject + '</td></tr>';
                        html += '<tr><td>' + i18n['processor.jwt.expires'] + '</td><td>' + 
                               new Date(response.expiresAt * 1000).toLocaleString() + '</td></tr>';
                        
                        // Add claims with improved formatting
                        html += '<tr><td colspan="2"><h4>' + i18n['processor.jwt.claims'] + '</h4></td></tr>';
                        for (var claim in response.claims) {
                            var claimValue = response.claims[claim];
                            // Format claim value based on type
                            var displayValue = typeof claimValue === 'object' ? 
                                              JSON.stringify(claimValue, null, 2) : String(claimValue);
                            html += '<tr><td>' + claim + ':</td><td><pre>' + displayValue + '</pre></td></tr>';
                        }
                        
                        // Add attributes that would be added
                        html += '<tr><td colspan="2"><h4>' + i18n['processor.jwt.flowFileAttributes'] + '</h4></td></tr>';
                        for (var attr in response.attributes) {
                            html += '<tr><td>' + attr + ':</td><td>' + response.attributes[attr] + '</td></tr>';
                        }
                        
                        html += '</table>';
                        html += '</div>';
                        resultContainer.html(html);
                    } else {
                        // Show error message with improved formatting
                        var html = '<div class="message-error">' + i18n['processor.jwt.tokenInvalid'] + '</div>';
                        html += '<div class="error-details">';
                        html += '<h4>' + i18n['processor.jwt.errorDetails'] + '</h4>';
                        html += '<p>' + response.reason + '</p>';
                        
                        // Add error code if available
                        if (response.errorCode) {
                            html += '<p><strong>Error Code:</strong> ' + response.errorCode + '</p>';
                        }
                        
                        // Add suggestion if available
                        if (response.suggestion) {
                            html += '<h4>' + i18n['processor.jwt.suggestion'] + '</h4>';
                            html += '<p>' + response.suggestion + '</p>';
                        }
                        
                        html += '</div>';
                        resultContainer.html(html);
                    }
                }).fail(function (xhr) {
                    resultContainer.html('<div class="message-error">' + i18n['processor.jwt.verificationFailed'] + 
                                         xhr.responseText + '</div>');
                });
            });
            
            callback();
        },
        
        /**
         * Clean up any resources before the element is removed from the DOM.
         */
        cleanup: function (element) {
            $(element).find('.verify-token-button').off();
        }
    };
}
----

== Configuration Examples for NiFi 2.3.0

=== Basic Configuration
_See Requirement link:../Requirements.adoc#NIFI-AUTH-7.2[NIFI-AUTH-7.2: Token Validation Configuration]_

[source,properties]
----
# Static properties
Token Header Name: Authorization
JWKS Refresh Interval: 15 min
Require Valid Token: true
Token Location: AUTHORIZATION_HEADER

# Dynamic properties (issuers)
keycloak: https://auth.example.com/realms/master/protocol/openid-connect/certs
azure: https://login.microsoftonline.com/common/discovery/keys
----

=== Multi-Issuer Configuration with Custom Token Location
_See Requirement link:../Requirements.adoc#NIFI-AUTH-4[NIFI-AUTH-4: Multiple Issuer Support]_

[source,properties]
----
# Static properties
Token Header Name: Authorization
JWKS Refresh Interval: 30 min
Require Valid Token: true
Token Location: CUSTOM_HEADER
Custom Header Name: X-JWT-Token

# Dynamic properties (issuers)
internal-keycloak: https://auth.internal.example.com/realms/master/protocol/openid-connect/certs
customer-keycloak: https://auth.customer.example.com/realms/master/protocol/openid-connect/certs
partner-auth: https://auth.partner.example.com/.well-known/jwks.json
legacy-system: -----BEGIN PUBLIC KEY-----\nMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA...
----

=== Content-Based Token Validation
_See Requirement link:../Requirements.adoc#NIFI-AUTH-5.1[NIFI-AUTH-5.1: Token Location]_

[source,properties]
----
# Static properties
Token Header Name: Authorization
JWKS Refresh Interval: 15 min
Require Valid Token: true
Token Location: FLOW_FILE_CONTENT

# Dynamic properties (issuers)
keycloak: https://auth.example.com/realms/master/protocol/openid-connect/certs
----

== See Also

* link:token-validation.adoc[Token Validation]
* link:security.adoc[Security]
* link:technical-components.adoc[Technical Components]
* link:integration-patterns.adoc[Integration Patterns]
* link:../Requirements.adoc[Requirements]
* link:../Specification.adoc[Main Specification]
