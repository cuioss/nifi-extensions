= MultiIssuerJWTTokenAuthenticator Technical Components
:toc:
:toclevels: 3
:toc-title: Table of Contents
:sectnums:

link:../Specification.adoc[Back to Main Specification]

== Processor Implementation
_See Requirement link:../Requirements.adoc#NIFI-AUTH-2[NIFI-AUTH-2: Core Functionality]_

[cols="1,2"]
|===
|Component |Specification

|Package
|de.cuioss.nifi.processors.auth

|Class Name
|MultiIssuerJWTTokenAuthenticator

|Base Class
|AbstractProcessor
|===

== Dependencies
_See Requirement link:../Requirements.adoc#NIFI-AUTH-11[NIFI-AUTH-11: NiFi Integration]_

[cols="1,2"]
|===
|Component |Purpose

|de.cuioss.portal.authentication:portal-authentication-token
|Token handling framework

|cui-java-tools
|Logging and utilities

|cui-i18n-bundle
|Internationalization support
|===

== Core Components
_See Requirement link:../Requirements.adoc#NIFI-AUTH-2.1[NIFI-AUTH-2.1: Core Components]_

=== TokenValidator
_See Requirement link:../Requirements.adoc#NIFI-AUTH-3[NIFI-AUTH-3: Token Validation Requirements]_

The TokenValidator serves as the primary entry point for token operations. It provides:

* Centralized token validation
* Multi-issuer support
* Token parsing and verification

=== IssuerConfig
_See Requirement link:../Requirements.adoc#NIFI-AUTH-3[NIFI-AUTH-3: Token Validation Requirements]_

The IssuerConfig handles secure token validation using JWKS endpoints:

* Automatic public key retrieval and caching
* Configurable key refresh intervals
* TLS support for secure key retrieval

[source,java]
----
// Configure an issuer config for a specific issuer
IssuerConfig issuerConfig = IssuerConfig.builder()
    .jwksIssuer("https://auth.example.com")
    .jwksEndpoint("https://auth.example.com/.well-known/jwks.json")
    .jwksRefreshIntervall(60)
    .build();
----

=== Multi-Issuer Support
_See Requirement link:../Requirements.adoc#NIFI-AUTH-4[NIFI-AUTH-4: Multiple Issuer Support]_

The MultiIssuerJWTTokenAuthenticator supports multiple issuers by utilizing a TokenValidator with multiple IssuerConfig instances.

[source,java]
----
// Create a validator with multiple issuer configs for different issuers
TokenValidator validator = new TokenValidator(issuerConfig1, issuerConfig2, issuerConfig3);

// Use the validator to validate tokens from different issuers
Optional<AccessTokenContent> accessToken = validator.createAccessToken(tokenString);
----

== Relationships
_See Requirement link:../Requirements.adoc#NIFI-AUTH-6[NIFI-AUTH-6: Output Requirements]_

[cols="1,2"]
|===
|Relationship |Description

|success
|FlowFiles that have been successfully processed with valid token data attached

|failure
|FlowFiles that contained invalid tokens or encountered errors during processing

|unauthorized
|FlowFiles that contained tokens that failed validation (expired, invalid signature, etc.)
|===

[source,java]
----
public static final Relationship SUCCESS = new Relationship.Builder()
    .name("success")
    .description("FlowFiles with valid tokens will be routed to this relationship")
    .build();

public static final Relationship AUTHENTICATION_FAILED = new Relationship.Builder()
    .name("authentication-failed")
    .description("FlowFiles with invalid tokens will be routed to this relationship")
    .build();

@Override
public Set<Relationship> getRelationships() {
    final Set<Relationship> relationships = new HashSet<>();
    relationships.add(SUCCESS);
    relationships.add(AUTHENTICATION_FAILED);
    return relationships;
}
----

== Flow File Attribute Handling

=== Input Attributes
_See Requirement link:../Requirements.adoc#NIFI-AUTH-5[NIFI-AUTH-5: Input Requirements]_

* None required - token extracted from HTTP header

=== Output Attributes (Success)
_See Requirement link:../Requirements.adoc#NIFI-AUTH-6.1[NIFI-AUTH-6.1: Success Path]_

* jwt.issuer: Token issuer
* jwt.subject: Token subject
* jwt.claims.*: All extracted claims
* jwt.validatedAt: Validation timestamp
* jwt.scopes: List of token scopes

=== Output Attributes (Failure)
_See Requirement link:../Requirements.adoc#NIFI-AUTH-6.2[NIFI-AUTH-6.2: Failure Path]_

* jwt.error.reason: Detailed error message
* jwt.error.code: Error classification code
* jwt.authorization.failed.reason: If token was valid but authorization failed, contains the reason

[source,java]
----
private void addSuccessAttributes(FlowFile flowFile, ParsedJwtToken token) {
    Map<String, String> attributes = new HashMap<>();

    // Add basic token information
    attributes.put("jwt.issuer", token.getIssuer());
    attributes.put("jwt.subject", token.getSubject());
    attributes.put("jwt.validatedAt", String.valueOf(System.currentTimeMillis()));

    // Add all claims as attributes
    for (Map.Entry<String, Object> claim : token.getClaims().entrySet()) {
        attributes.put("jwt.claims." + claim.getKey(), 
                       claim.getValue() != null ? claim.getValue().toString() : "");
    }

    // Add scopes
    attributes.put("jwt.scopes", String.join(",", token.getScopes()));

    // Add authorization status
    attributes.put("jwt.authorization.passed", "true");

    // Update flowfile with attributes
    flowFile = session.putAllAttributes(flowFile, attributes);
}
----

== JavaScript Module Structure

=== Directory Organization

The JavaScript code is organized according to the following structure:

[source]
----
src/
└── main/
    └── resources/
        └── js/
            ├── components/      # UI Components
            │   ├── jwks-endpoint-validator.js
            │   └── token-verification.js
            ├── services/        # API and utility services
            │   ├── api-client.js
            │   └── token-parser.js
            ├── utils/           # Utility functions
            │   ├── validation.js
            │   └── formatting.js
            └── index.js         # Main entry point
----

This structure provides clear separation of concerns:

* *components/* - Contains UI components and their associated logic
* *services/* - Houses service modules for API communication and core functionality
* *utils/* - Provides utility functions and helpers that are used across the application

=== Module Naming Conventions

JavaScript modules follow these naming conventions:

* Module files use kebab-case naming (e.g., `jwks-endpoint-validator.js`)
* Functions and variables use camelCase naming (e.g., `validateEndpoint()`)
* Classes and constructor functions use PascalCase (e.g., `TokenValidator`)
* Constants use UPPER_SNAKE_CASE (e.g., `DEFAULT_REFRESH_INTERVAL`)

=== Module Export Pattern

Each module should have a clear, consistent export pattern:

[source,javascript]
----
// Service module example
const TokenService = {
  parseToken,
  validateToken,
  extractClaims
};

export default TokenService;
----

=== Integration Points

The JavaScript module and the main Java modules integrate through:

1. REST API endpoints for JWKS validation and token verification
2. WebJar packaging of JavaScript resources
3. Maven build integration

== See Also

* link:token-validation.adoc[Token Validation] - Details on the token validation process
* link:configuration.adoc[Configuration] - Configuration properties and UI
* link:security.adoc[Security] - Security considerations
* link:error-handling.adoc[Error Handling] - Details on error handling
* link:../Specification.adoc[Back to Main Specification]
