= MultiIssuerJWTTokenAuthenticator Specification
:toc:
:toclevels: 3
:toc-title: Table of Contents
:sectnums:

== Overview
This document provides the technical specification for implementing the MultiIssuerJWTTokenAuthenticator processor.
For functional requirements, see link:requirements.adoc[Requirements Document].

== Technical Components

=== Processor Implementation
[cols="1,2"]
|===
|Component |Specification

|Package
|de.cuioss.nifi.processors.cuioss.auth

|Class Name
|MultiIssuerJWTTokenAuthenticator

|Base Class
|AbstractProcessor
|===

=== Dependencies
[cols="1,2"]
|===
|Component |Purpose

|portal-authentication-token
|Core JWT validation functionality using `TokenFactory` and `JwksAwareTokenParser`

|portal-keycloak-integration-test
|Integration testing framework for token validation
|===

== Implementation Details

=== Token Validation Flow
[plantuml]
....
@startuml
participant "HandleHttpRequest" as http
participant "MultiIssuerJWTTokenAuthenticator" as auth
participant "TokenFactory" as factory
participant "JwksAwareTokenParser" as parser
database "JWKS Endpoint" as jwks

http -> auth: FlowFile with\nBearer Token
activate auth

auth -> auth: Extract Bearer Token
auth -> factory: Validate Token
activate factory

factory -> parser: Parse Token
activate parser

alt JWKS Configuration
    parser -> jwks: Fetch Public Keys
    jwks --> parser: JWKS Response
else Direct Public Key
    parser -> parser: Use Configured\nPublic Key
end

parser --> factory: Validation Result
deactivate parser

factory --> auth: ParsedAccessToken
deactivate factory

alt Valid Token
    auth -> auth: Extract Claims
    auth --> http: Route to 'success'
else Invalid Token
    auth -> auth: Create Error Details
    auth --> http: Route to 'authentication-failed'
end

deactivate auth
@enduml
....

=== Core Components

==== TokenFactory Integration
* Utilizes `TokenFactory` from portal-authentication-token
* Configures multiple `JwksAwareTokenParser` instances based on UI configuration
* Handles token validation and parsing

===== Implementation Example
[source,java]
----
private TokenFactory createTokenFactory() {
    TokenFactory factory = new TokenFactory();
    
    // Configure parsers for each issuer
    for (Map.Entry<String, String> issuerConfig : getIssuerConfigurations().entrySet()) {
        String issuerId = issuerConfig.getKey();
        String configValue = issuerConfig.getValue();
        
        JwksAwareTokenParser parser;
        if (configValue.startsWith("http")) {
            // JWKS URL configuration
            parser = new JwksAwareTokenParser(issuerId, configValue);
            parser.setJwksRefreshInterval(getJwksRefreshInterval());
        } else {
            // Direct public key configuration
            parser = new JwksAwareTokenParser(issuerId, parsePublicKey(configValue));
        }
        
        factory.registerTokenParser(issuerId, parser);
    }
    
    return factory;
}
----

==== Configuration Management
===== Token Validation Configuration
* Dynamic Properties for Issuer Configuration:
** Property Name: Issuer Identifier
** Property Value: JWKS URL or Public Key (PEM format)
* Regular Properties:
** Token Header Name (default: Authorization)
** Token Refresh Interval (minutes)

===== JWKS Endpoint Test Button Implementation
* Implement custom UI element using NiFi's CustomUiContext
* Add "Test Connection" button next to JWKS URL properties
* Button triggers asynchronous HTTP request to validate JWKS endpoint

[source,java]
----
@Override
protected PropertyDescriptor getSupportedDynamicPropertyDescriptor(final String propertyDescriptorName) {
    return new PropertyDescriptor.Builder()
        .name(propertyDescriptorName)
        .displayName("Issuer Configuration: " + propertyDescriptorName)
        .description("Configuration for issuer: " + propertyDescriptorName + 
                     ". Value can be either a JWKS URL or a PEM-encoded public key.")
        .required(true)
        .dynamic(true)
        .addValidator(StandardValidators.NON_EMPTY_VALIDATOR)
        .identifiesControllerService(JwksEndpointValidator.class)
        .build();
}
----

===== Token Verification Implementation
* Implement token verification UI using NiFi's CustomUiContext
* Add "Verification" tab in processor configuration
* Provide interface for testing tokens against current configuration

[plantuml]
....
@startuml
skinparam componentStyle rectangle

package "NiFi UI" {
  [Token Verification UI] as ui
}

package "NiFi Backend" {
  [Token Verification Endpoint] as endpoint
  [MultiIssuerJWTTokenAuthenticator] as processor
  [TokenFactory] as factory
}

ui --> endpoint : HTTP Request with token
endpoint --> processor : Validate token
processor --> factory : Parse and validate
factory --> processor : Validation result
processor --> endpoint : Result with details
endpoint --> ui : JSON response
@enduml
....

===== Token Verification UI
* Custom UI implementation with text area for token input
* "Verify Token" button to submit token for validation
* Results display area showing validation outcome and details

[source,javascript]
----
// UI Extension for Token Verification
define(['jquery'], function ($) {
    return {
        /**
         * Initialize the custom UI.
         */
        init: function (element, processorId, callback) {
            // Create UI elements
            var container = $('<div class="token-verification-container"></div>');
            var tokenInput = $('<textarea class="token-input" placeholder="Paste JWT token here..."></textarea>');
            var verifyButton = $('<button type="button" class="verify-token-button">Verify Token</button>');
            var resultContainer = $('<div class="verification-result"></div>');
            
            // Add elements to the DOM
            container.append($('<h3>Token Verification</h3>'))
                    .append($('<p>Test a JWT token against the current processor configuration.</p>'))
                    .append(tokenInput)
                    .append(verifyButton)
                    .append(resultContainer);
            
            $(element).append(container);
            
            // Handle button click
            verifyButton.on('click', function () {
                var token = tokenInput.val().trim();
                if (!token) {
                    resultContainer.html('<div class="message-warning">Please enter a JWT token.</div>');
                    return;
                }
                
                resultContainer.html('<div class="message-info"><span class="fa fa-spinner fa-spin"></span> Verifying token...</div>');
                
                // Make AJAX request to verify the token
                $.ajax({
                    type: 'POST',
                    url: '../nifi-api/processors/' + processorId + '/verify-token',
                    data: JSON.stringify({
                        token: token
                    }),
                    contentType: 'application/json',
                    dataType: 'json'
                }).done(function (response) {
                    if (response.valid) {
                        // Display success with token details
                        var html = '<div class="message-success">' +
                                   '<h4><span class="fa fa-check-circle"></span> Token is valid</h4>' +
                                   '<p>Validated by issuer: <strong>' + response.issuer + '</strong></p>' +
                                   '</div>';
                                   
                        // Display claims
                        html += '<div class="token-claims">' +
                                '<h4>Token Claims</h4>' +
                                '<table class="claims-table">' +
                                '<tr><th>Claim</th><th>Value</th></tr>';
                                
                        for (var claim in response.claims) {
                            html += '<tr><td>' + claim + '</td><td>' + 
                                    formatClaimValue(response.claims[claim]) + '</td></tr>';
                        }
                        
                        html += '</table></div>';
                        
                        // Display flow file attributes
                        html += '<div class="flow-attributes">' +
                                '<h4>Flow File Attributes</h4>' +
                                '<table class="attributes-table">' +
                                '<tr><th>Attribute</th><th>Value</th></tr>';
                                
                        for (var attr in response.attributes) {
                            html += '<tr><td>' + attr + '</td><td>' + response.attributes[attr] + '</td></tr>';
                        }
                        
                        html += '</table></div>';
                        
                        resultContainer.html(html);
                    } else {
                        // Display failure with error details
                        var html = '<div class="message-error">' +
                                   '<h4><span class="fa fa-times-circle"></span> Token is invalid</h4>' +
                                   '<p>Error: <strong>' + response.errorReason + '</strong></p>';
                                   
                        // Add suggestion if available
                        if (response.suggestion) {
                            html += '<p>Suggestion: ' + response.suggestion + '</p>';
                        }
                        
                        html += '</div>';
                        
                        // Add error details if available
                        if (response.errorDetails) {
                            html += '<div class="error-details">' +
                                    '<h4>Error Details</h4>' +
                                    '<pre>' + response.errorDetails + '</pre>' +
                                    '</div>';
                        }
                        
                        resultContainer.html(html);
                    }
                }).fail(function (xhr) {
                    resultContainer.html('<div class="message-error">' +
                                         '<h4><span class="fa fa-exclamation-triangle"></span> Verification failed</h4>' +
                                         '<p>Error: ' + xhr.responseText + '</p>' +
                                         '</div>');
                });
            });
            
            // Helper function to format claim values
            function formatClaimValue(value) {
                if (typeof value === 'object') {
                    return JSON.stringify(value);
                }
                return value;
            }
            
            // Call the callback to indicate initialization is complete
            callback();
        },
        
        /**
         * Clean up any resources before the element is removed from the DOM.
         */
        cleanup: function (element) {
            $(element).find('.verify-token-button').off();
        }
    };
});
----

===== Token Verification REST Endpoint
* Implement REST endpoint for token verification
* Process token using current processor configuration
* Return validation results with claims and attributes

[source,java]
----
@Path("/processors/{id}")
@Api(value = "Processor")
public class ProcessorResource extends ApplicationResource {
    
    // Other methods omitted for brevity
    
    @POST
    @Path("/verify-token")
    @Consumes(MediaType.APPLICATION_JSON)
    @Produces(MediaType.APPLICATION_JSON)
    @ApiOperation(value = "Verifies a JWT token against processor configuration")
    public Response verifyToken(
            @PathParam("id") final String processorId,
            @ApiParam(value = "The token verification request", required = true)
            final TokenVerificationRequest request) {
        
        // Get the processor instance
        ProcessorNode processorNode = getProcessorNode(processorId);
        if (processorNode == null) {
            return Response.status(Status.NOT_FOUND).entity("Processor not found").build();
        }
        
        // Check if processor is the correct type
        if (!(processorNode.getProcessor() instanceof MultiIssuerJWTTokenAuthenticator)) {
            return Response.status(Status.BAD_REQUEST)
                    .entity("Processor is not a MultiIssuerJWTTokenAuthenticator")
                    .build();
        }
        
        // Get the processor instance
        MultiIssuerJWTTokenAuthenticator processor = 
                (MultiIssuerJWTTokenAuthenticator) processorNode.getProcessor();
        
        // Verify the token
        TokenVerificationResult result = processor.verifyToken(request.getToken());
        
        // Return the result
        return Response.ok(result).build();
    }
    
    private ProcessorNode getProcessorNode(String processorId) {
        // Get the processor from the flow controller
        return getFlowController().getFlowManager().getProcessorNode(processorId);
    }
}
----

===== Token Verification Implementation in Processor
* Add method to processor for token verification
* Use existing TokenFactory for validation
* Return structured result with claims and attributes

[source,java]
----
/**
 * Verifies a token against the current processor configuration.
 * This method is used by the token verification UI and does not affect
 * processor state or flow files.
 * 
 * @param token The JWT token to verify
 * @return TokenVerificationResult containing validation results
 */
public TokenVerificationResult verifyToken(String token) {
    try {
        // Extract the token if it's in Bearer format
        if (token.startsWith("Bearer ")) {
            token = token.substring(7);
        }
        
        // Validate the token
        TokenFactory tokenFactory = getTokenFactory();
        ParsedAccessToken parsedToken = tokenFactory.parseToken(token);
        
        // Create result with token details
        TokenVerificationResult result = new TokenVerificationResult();
        result.setValid(true);
        result.setIssuer(parsedToken.getIssuer());
        result.setClaims(parsedToken.getClaims());
        
        // Create mock flow file to simulate attribute generation
        Map<String, String> attributes = new HashMap<>();
        addSuccessAttributes(attributes, parsedToken);
        result.setAttributes(attributes);
        
        // Check authorization requirements
        if (!meetsAuthorizationRequirements(parsedToken)) {
            result.setAuthorizationWarning(
                "Token is valid but does not meet authorization requirements. " +
                "It would be routed to 'authentication-failed' relationship.");
        }
        
        return result;
    } catch (TokenValidationException e) {
        // Create failure result
        TokenVerificationResult result = new TokenVerificationResult();
        result.setValid(false);
        result.setErrorReason(e.getMessage());
        result.setErrorCode(mapErrorToCode(e));
        
        // Add suggestion based on error type
        result.setSuggestion(getSuggestionForError(e));
        
        // Add detailed error information
        StringWriter sw = new StringWriter();
        e.printStackTrace(new PrintWriter(sw));
        result.setErrorDetails(sw.toString());
        
        return result;
    }
}

/**
 * Provides a suggestion based on the type of error.
 */
private String getSuggestionForError(TokenValidationException e) {
    if (e instanceof TokenExpiredException) {
        return "The token has expired. Request a new token from the authorization server.";
    } else if (e instanceof InvalidSignatureException) {
        return "The token signature is invalid. Verify the signing key configuration.";
    } else if (e instanceof UnknownIssuerException) {
        return "The token issuer is not configured. Add the issuer to the processor configuration.";
    } else if (e instanceof MalformedTokenException) {
        return "The token format is invalid. Verify that you are using a valid JWT token.";
    } else if (e instanceof MissingClaimException) {
        return "The token is missing a required claim. Check the token contents.";
    }
    return "Verify your token and issuer configuration.";
}
----

===== Token Verification Result Model
* Define model class for token verification results
* Include fields for validation status, claims, and attributes

[source,java]
----
/**
 * Model class for token verification results.
 */
public class TokenVerificationResult {
    private boolean valid;
    private String issuer;
    private Map<String, Object> claims;
    private Map<String, String> attributes;
    private String errorReason;
    private int errorCode;
    private String errorDetails;
    private String suggestion;
    private String authorizationWarning;
    
    // Getters and setters omitted for brevity
}
----

===== JWKS Endpoint Validator Service
* Create a controller service interface for JWKS endpoint validation
* Implement the validation logic in a service implementation

[source,java]
----
public interface JwksEndpointValidator extends ControllerService {
    ValidationResult validateJwksEndpoint(String jwksUrl);
}

@Tags({"jwt", "jwks", "validator"})
@CapabilityDescription("Provides validation capabilities for JWKS endpoints")
public class StandardJwksEndpointValidator extends AbstractControllerService implements JwksEndpointValidator {
    
    private static final CuiLogger LOGGER = new CuiLogger(StandardJwksEndpointValidator.class);
    
    @Override
    public ValidationResult validateJwksEndpoint(String jwksUrl) {
        try {
            // Create HTTP client with appropriate timeouts
            OkHttpClient client = new OkHttpClient.Builder()
                .connectTimeout(5, TimeUnit.SECONDS)
                .readTimeout(5, TimeUnit.SECONDS)
                .build();
                
            // Create request
            Request request = new Request.Builder()
                .url(jwksUrl)
                .get()
                .build();
                
            // Execute request
            Response response = client.newCall(request).execute();
            
            // Check response
            if (response.isSuccessful()) {
                String body = response.body().string();
                // Validate JWKS format
                if (isValidJwksFormat(body)) {
                    return new ValidationResult.Builder()
                        .valid(true)
                        .explanation("Successfully connected to JWKS endpoint")
                        .build();
                } else {
                    return new ValidationResult.Builder()
                        .valid(false)
                        .explanation("Response is not a valid JWKS format")
                        .build();
                }
            } else {
                return new ValidationResult.Builder()
                    .valid(false)
                    .explanation("Failed to connect to JWKS endpoint: HTTP " + response.code())
                    .build();
            }
        } catch (Exception e) {
            LOGGER.error(e, "Error validating JWKS endpoint: %s", e.getMessage());
            return new ValidationResult.Builder()
                .valid(false)
                .explanation("Error connecting to JWKS endpoint: " + e.getMessage())
                .build();
        }
    }
    
    private boolean isValidJwksFormat(String body) {
        try {
            JsonObject jwks = JsonParser.parseString(body).getAsJsonObject();
            return jwks.has("keys") && jwks.get("keys").isJsonArray();
        } catch (Exception e) {
            return false;
        }
    }
}
----

===== Custom UI Implementation
* Implement custom UI for the "Test Connection" button using NiFi's UI extension framework
* Button appears next to JWKS URL properties
* On click, sends AJAX request to validate endpoint
* Displays success/failure message with appropriate styling

[source,javascript]
----
// UI Extension for JWKS Test Button
define(['jquery'], function ($) {
    return {
        /**
         * Initialize the custom UI.
         */
        init: function (element, propertyDescriptor, propertyValue, callback) {
            // Create the test button
            var testButton = $('<button type="button" class="test-jwks-button">Test Connection</button>');
            var resultContainer = $('<div class="test-jwks-result"></div>');
            
            // Add elements to the DOM
            $(element).append(testButton).append(resultContainer);
            
            // Handle button click
            testButton.on('click', function () {
                // Only test if the value looks like a URL
                if (propertyValue && propertyValue.startsWith('http')) {
                    resultContainer.html('<span class="fa fa-spinner fa-spin"></span> Testing connection...');
                    
                    // Make AJAX request to test the connection
                    $.ajax({
                        type: 'POST',
                        url: '../nifi-api/processors/validate-jwks',
                        data: JSON.stringify({
                            jwksUrl: propertyValue
                        }),
                        contentType: 'application/json',
                        dataType: 'json'
                    }).done(function (response) {
                        if (response.valid) {
                            resultContainer.html('<span class="fa fa-check" style="color: green;"></span> ' + 
                                                 'Connection successful');
                        } else {
                            resultContainer.html('<span class="fa fa-times" style="color: red;"></span> ' + 
                                                 'Connection failed: ' + response.explanation);
                        }
                    }).fail(function (xhr) {
                        resultContainer.html('<span class="fa fa-times" style="color: red;"></span> ' + 
                                             'Test failed: ' + xhr.responseText);
                    });
                } else {
                    resultContainer.html('<span class="fa fa-info-circle" style="color: blue;"></span> ' + 
                                         'Please enter a valid JWKS URL starting with http:// or https://');
                }
            });
            
            // Call the callback to indicate initialization is complete
            callback();
        },
        
        /**
         * Clean up any resources before the element is removed from the DOM.
         */
        cleanup: function (element) {
            $(element).find('.test-jwks-button').off();
        }
    };
});
----

===== REST Endpoint for JWKS Validation
* Implement a REST endpoint in the NiFi API to handle JWKS validation requests
* Endpoint calls the JwksEndpointValidator service to perform validation
* Returns validation result as JSON

[source,java]
----
@Path("/processors")
@Api(value = "Processors")
public class ProcessorResource extends ApplicationResource {
    
    // Other methods omitted for brevity
    
    @POST
    @Path("/validate-jwks")
    @Consumes(MediaType.APPLICATION_JSON)
    @Produces(MediaType.APPLICATION_JSON)
    @ApiOperation(value = "Validates a JWKS endpoint URL")
    public Response validateJwksEndpoint(
            @ApiParam(value = "The JWKS URL validation request", required = true)
            final JwksValidationRequest request) {
        
        // Get the validator service
        JwksEndpointValidator validator = getJwksEndpointValidator();
        
        // Validate the JWKS endpoint
        ValidationResult result = validator.validateJwksEndpoint(request.getJwksUrl());
        
        // Return the result
        return Response.ok(result).build();
    }
    
    private JwksEndpointValidator getJwksEndpointValidator() {
        // Get the validator service from the controller service provider
        return getControllerServiceLookup().getControllerServiceByType(JwksEndpointValidator.class);
    }
}
----

===== Authorization Configuration
[cols="2,1,2"]
|===
|Property |Type |Description

|Require Valid Token
|Boolean
|When true, only valid tokens result in success relationship

|Required Scopes
|List<String>
|List of OAuth scopes that must be present in token

|Required Roles
|List<String>
|List of roles that must be present in token
|===

===== Configuration Example
[source,java]
----
@Override
protected List<PropertyDescriptor> getSupportedPropertyDescriptors() {
    final List<PropertyDescriptor> properties = new ArrayList<>();
    properties.add(TOKEN_HEADER);
    properties.add(JWKS_REFRESH_INTERVAL);
    properties.add(REQUIRE_VALID_TOKEN);
    properties.add(REQUIRED_SCOPES);
    properties.add(REQUIRED_ROLES);
    return properties;
}

@Override
protected PropertyDescriptor getSupportedDynamicPropertyDescriptor(final String propertyDescriptorName) {
    return new PropertyDescriptor.Builder()
        .name(propertyDescriptorName)
        .displayName("Issuer Configuration: " + propertyDescriptorName)
        .description("Configuration for issuer: " + propertyDescriptorName + 
                     ". Value can be either a JWKS URL or a PEM-encoded public key.")
        .required(true)
        .dynamic(true)
        .addValidator(StandardValidators.NON_EMPTY_VALIDATOR)
        .build();
}
----

=== Relationships
[cols="1,2"]
|===
|Relationship |Description

|success
|Valid tokens with extracted claims as attributes

|authentication-failed
|Invalid tokens with error details
|===

===== Relationships Example
[source,java]
----
public static final Relationship SUCCESS = new Relationship.Builder()
    .name("success")
    .description("FlowFiles with valid tokens will be routed to this relationship")
    .build();

public static final Relationship AUTHENTICATION_FAILED = new Relationship.Builder()
    .name("authentication-failed")
    .description("FlowFiles with invalid tokens will be routed to this relationship")
    .build();

@Override
public Set<Relationship> getRelationships() {
    final Set<Relationship> relationships = new HashSet<>();
    relationships.add(SUCCESS);
    relationships.add(AUTHENTICATION_FAILED);
    return relationships;
}
----

=== Flow File Attribute Handling

==== Input Attributes
* None required - token extracted from HTTP header

==== Output Attributes (Success)
* jwt.issuer: Token issuer
* jwt.subject: Token subject
* jwt.claims.*: All extracted claims
* jwt.validatedAt: Validation timestamp
* jwt.scopes: List of token scopes
* jwt.roles: List of token roles
* jwt.authorization.passed: Boolean indicating if all authorization requirements were met

==== Output Attributes (Failure)
* jwt.error.reason: Detailed error message
* jwt.error.code: Error classification code
* jwt.authorization.failed.reason: If token was valid but authorization failed, contains the reason

===== Attribute Handling Example
[source,java]
----
private void addSuccessAttributes(FlowFile flowFile, ParsedAccessToken token) {
    Map<String, String> attributes = new HashMap<>();
    
    // Add basic token information
    attributes.put("jwt.issuer", token.getIssuer());
    attributes.put("jwt.subject", token.getSubject());
    attributes.put("jwt.validatedAt", String.valueOf(System.currentTimeMillis()));
    
    // Add all claims as attributes
    for (Map.Entry<String, Object> claim : token.getClaims().entrySet()) {
        attributes.put("jwt.claims." + claim.getKey(), 
                       claim.getValue() != null ? claim.getValue().toString() : "");
    }
    
    // Add scopes and roles
    attributes.put("jwt.scopes", String.join(",", token.getScopes()));
    attributes.put("jwt.roles", String.join(",", token.getRoles()));
    
    // Add authorization status
    attributes.put("jwt.authorization.passed", "true");
    
    // Update flowfile with attributes
    flowFile = session.putAllAttributes(flowFile, attributes);
}

private void addFailureAttributes(FlowFile flowFile, TokenValidationException e) {
    Map<String, String> attributes = new HashMap<>();
    
    // Add error information
    attributes.put("jwt.error.reason", e.getMessage());
    attributes.put("jwt.error.code", String.valueOf(mapErrorToCode(e)));
    
    // Update flowfile with attributes
    flowFile = session.putAllAttributes(flowFile, attributes);
}
----

=== Authorization Flow
[plantuml]
....
@startuml
start
:Validate Token;

if (Token Valid?) then (yes)
  if (Require Valid Token?) then (yes)
    if (Check Required Scopes) then (present)
      if (Check Required Roles) then (present)
        :Route to 'success';
      else (missing)
        :Add authorization.failed.reason;
        :Route to 'authentication-failed';
      endif
    else (missing)
      :Add authorization.failed.reason;
      :Route to 'authentication-failed';
    endif
  else (no)
    :Route to 'success';
  endif
else (no)
  :Add error details;
  :Route to 'authentication-failed';
endif
stop
@enduml
....

=== Error Handling Implementation

==== Error Code Mapping
[cols="1,2,2"]
|===
|Error Category |Code Range |Example

|INFO Level Messages
|001-099
|001: Successfully validated token from issuer

|WARN Level Messages
|100-199
|100: Token validation failed

|ERROR Level Messages
|200-299
|200: Failed to connect to JWKS endpoint
|===

==== Error Handling Example
[source,java]
----
private int mapErrorToCode(TokenValidationException e) {
    if (e instanceof TokenExpiredException) {
        return 200;
    } else if (e instanceof InvalidSignatureException) {
        return 201;
    } else if (e instanceof UnknownIssuerException) {
        return 202;
    } else if (e instanceof MalformedTokenException) {
        return 203;
    } else if (e instanceof MissingClaimException) {
        return 204;
    } else if (e instanceof AuthorizationException) {
        return 100;
    } else {
        // Default error code
        return 200;
    }
}
----

=== Logging Implementation
* Uses `de.cuioss.tools.logging.CuiLogger` (LOGGER constant)
* Error pattern: `LOGGER.error(e, JWTAuth-%03d.format(params))`
* All messages documented in <<LogMessage.md,Log Messages>>
* Test coverage verified via `LogAsserts`

== Integration Testing

=== Test Framework
* Utilizes portal-keycloak-integration-test
* Provides mock JWKS endpoints
* Generates test tokens

=== Test Scenarios
* See link:requirements.adoc#testing-requirements[Testing Requirements]

==== Test Example
[source,java]
----
@Test
@DisplayName("Should validate token with JWKS endpoint")
void shouldValidateTokenWithJwksEndpoint() {
    // Arrange
    final TestRunner runner = TestRunners.newTestRunner(MultiIssuerJWTTokenAuthenticator.class);
    
    // Configure processor with mock JWKS endpoint
    runner.setProperty("test-issuer", mockJwksServer.getJwksUrl());
    runner.setProperty(MultiIssuerJWTTokenAuthenticator.REQUIRE_VALID_TOKEN, "true");
    
    // Create test token
    String token = mockJwksServer.createToken("test-issuer", "test-subject");
    
    // Create test flowfile with token
    Map<String, String> attributes = new HashMap<>();
    attributes.put("Authorization", "Bearer " + token);
    
    // Act
    runner.enqueue("test content", attributes);
    runner.run();
    
    // Assert
    runner.assertTransferCount(MultiIssuerJWTTokenAuthenticator.SUCCESS, 1);
    runner.assertTransferCount(MultiIssuerJWTTokenAuthenticator.AUTHENTICATION_FAILED, 0);
    
    // Verify attributes
    MockFlowFile resultFlowFile = runner.getFlowFilesForRelationship(
        MultiIssuerJWTTokenAuthenticator.SUCCESS).get(0);
    resultFlowFile.assertAttributeExists("jwt.issuer");
    resultFlowFile.assertAttributeEquals("jwt.issuer", "test-issuer");
    resultFlowFile.assertAttributeEquals("jwt.subject", "test-subject");
}
----

== Security Considerations

=== Token Handling
* No token storage in processor state
* Secure key handling for direct public key configuration
* Regular JWKS refresh for security updates

=== Error Handling
* No sensitive information in error messages
* Proper logging levels for security events
* Validation of configuration inputs

== Implementation Guidelines

=== Code Organization
* Follow NiFi processor development best practices
* Implement proper exception handling
* Use CuiLogger for logging

=== Configuration Validation
* Validate JWKS URLs
* Verify public key format
* Check required configuration properties

=== Performance Considerations
* Cache JWKS responses
* Optimize token validation path
* Handle concurrent requests efficiently

== Integration Examples

=== API Gateway Pattern
[plantuml]
....
@startuml
node "NiFi Flow" {
  [HandleHttpRequest] --> [MultiIssuerJWTTokenAuthenticator]
  [MultiIssuerJWTTokenAuthenticator] --> [RouteOnAttribute]
  [RouteOnAttribute] --> [InvokeBackendService]
  [RouteOnAttribute] --> [ReturnUnauthorized]
}
@enduml
....

=== Service-to-Service Authentication
[plantuml]
....
@startuml
node "NiFi Flow" {
  [GenerateFlowFile] --> [InvokeHTTP: Get Token]
  [InvokeHTTP: Get Token] --> [MultiIssuerJWTTokenAuthenticator]
  [MultiIssuerJWTTokenAuthenticator] --> [InvokeHTTP: Call Service]
}
@enduml
....

=== Multi-Tenant API Routing
[plantuml]
....
@startuml
node "NiFi Flow" {
  [HandleHttpRequest] --> [MultiIssuerJWTTokenAuthenticator]
  [MultiIssuerJWTTokenAuthenticator] --> [ExtractTenantId]
  [ExtractTenantId] --> [RouteOnAttribute]
  [RouteOnAttribute] --> [Tenant A Service]
  [RouteOnAttribute] --> [Tenant B Service]
  [RouteOnAttribute] --> [Tenant C Service]
}
@enduml
....
