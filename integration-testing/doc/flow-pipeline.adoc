= Flow Pipeline Integration Tests

The flow pipeline tests exercise the `MultiIssuerJWTTokenAuthenticator` processor inside a running NiFi instance.
HTTP requests go in, JWT validation happens, HTTP responses come back.

== How It Works

NiFi loads a pre-configured flow on startup (`flow.json`, gzipped as `flow.xml.gz`).
The flow listens on port 7777 and acts as a JWT authentication gateway:

----
HTTP Request (port 7777)
        │
        ▼
MultiIssuerJWTTokenAuthenticator
        │
   ┌────┴─────┐
   │          │
success   auth-failed
   │          │
   ▼          ▼
HTTP 200   HTTP 401
----

The full flow has 8 processors. The extra steps (LogAttribute, UpdateAttribute) exist so NiFi can set the response status code and log what happened:

. **HandleHttpRequest** -- accepts HTTP on port 7777
. **MultiIssuerJWTTokenAuthenticator** -- validates the JWT and checks roles
. **LogAttribute** (x2) -- logs attributes for debugging (one per path)
. **UpdateAttribute** (x2) -- sets `http.status.code` to 200 or 401
. **HandleHttpResponse** (x2) -- sends the response back to the caller

A **StandardHttpContextMap** controller service ties the request and response processors together.

== JWT Configuration

The authenticator is configured with one issuer pointing at Keycloak inside the Docker network:

- JWKS URL: `http://keycloak:8080/realms/oauth_integration_tests/protocol/openid-connect/certs`
- Issuer: `http://keycloak:8080/realms/oauth_integration_tests`
- Required role: `read`
- HTTPS for JWKS: disabled (Keycloak runs plain HTTP in Docker)

Only tokens with the `read` realm role get through. Everything else returns 401.

== Keycloak Setup

Two realms are pre-configured and auto-imported on startup.

=== `oauth_integration_tests` (primary)

[cols="1,1,1"]
|===
|User |Password |Roles

|testUser |drowssap |user, read
|limitedUser |drowssap |user
|===

Client: `test_client` / `yTKslWLtf4giJcWCaoVJ20H8sy6STexM`

=== `other_realm` (for signature testing)

A separate realm with its own RSA key pair. Tokens signed here cannot be verified by the primary realm's JWKS keys.

[cols="1,1,1"]
|===
|User |Password |Roles

|otherUser |drowssap |user
|===

Client: `other_client` / `otherClientSecretValue123456789`

== Tests

`NiFiFlowPipelineIT` sends HTTP requests to port 7777 and checks the status code.

[cols="2,1,2"]
|===
|Scenario |Expects |Why

|testUser token (has `read` role) |200 |Valid token, authorized
|limitedUser token (no `read` role) |401 |Valid token, not authorized
|Token from `other_realm` |401 |Wrong signature (different RSA key)
|No Authorization header |401 |Missing token
|`Bearer not-a-valid-jwt` |401 |Malformed token
|===

`@BeforeAll` waits up to 120 seconds for the flow endpoint to accept connections before running any tests.

== Running

----
# Start containers
./integration-testing/src/main/docker/run-and-deploy.sh

# Run the tests
./mvnw integration-test -Plocal-integration-tests -Dintegration.test.local=true

# Quick smoke test
TOKEN=$(curl -s -X POST http://localhost:9080/realms/oauth_integration_tests/protocol/openid-connect/token \
  -d 'grant_type=password&client_id=test_client&client_secret=yTKslWLtf4giJcWCaoVJ20H8sy6STexM&username=testUser&password=drowssap' \
  | python3 -c "import sys,json; print(json.load(sys.stdin)['access_token'])")

curl -v http://localhost:7777 -H "Authorization: Bearer $TOKEN"   # 200
curl -v http://localhost:7777                                       # 401
----

== Updating the Flow

Edit `flow.json`, then regenerate the gzipped file:

----
cd integration-testing/src/main/docker/nifi/conf
gzip -c flow.json > flow.xml.gz
----

NiFi 2.x reads JSON despite the `.xml.gz` filename. Restart the NiFi container after changes.
