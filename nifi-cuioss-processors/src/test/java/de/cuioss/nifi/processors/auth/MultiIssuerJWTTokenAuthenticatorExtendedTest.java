/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package de.cuioss.nifi.processors.auth;

import de.cuioss.sheriff.oauth.core.domain.claim.ClaimValue;
import de.cuioss.sheriff.oauth.core.test.InMemoryJWKSFactory;
import de.cuioss.sheriff.oauth.core.test.TestTokenHolder;
import de.cuioss.sheriff.oauth.core.test.generator.TestTokenGenerators;
import de.cuioss.test.juli.LogAsserts;
import de.cuioss.test.juli.TestLogLevel;
import de.cuioss.test.juli.junit5.EnableTestLogger;
import org.apache.nifi.components.PropertyDescriptor;
import org.apache.nifi.processor.ProcessContext;
import org.apache.nifi.util.MockFlowFile;
import org.apache.nifi.util.MockProcessContext;
import org.apache.nifi.util.TestRunner;
import org.apache.nifi.util.TestRunners;
import org.junit.jupiter.api.*;
import org.junit.jupiter.api.io.TempDir;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.HashMap;
import java.util.Map;

import static de.cuioss.nifi.processors.auth.JWTProcessorConstants.ISSUER_PREFIX;
import static de.cuioss.nifi.processors.auth.JWTProcessorConstants.Properties;
import static de.cuioss.nifi.processors.auth.JWTProcessorConstants.Relationships;
import static org.junit.jupiter.api.Assertions.*;

/**
 * Extended tests for {@link MultiIssuerJWTTokenAuthenticator} using real JWT tokens
 * generated by {@link TestTokenHolder} from oauth-sheriff-core test utilities.
 * <p>
 * Unlike the base test class which uses hardcoded HS256 tokens (always rejected),
 * these tests generate real RS256-signed tokens with matching JWKS key material,
 * enabling true SUCCESS path validation testing.
 *
 * @see <a href="https://github.com/cuioss/nifi-extensions/tree/main/doc/specification/technical-components.adoc">Technical Components Specification</a>
 * @see <a href="https://github.com/cuioss/nifi-extensions/tree/main/doc/specification/token-validation.adoc">Token Validation Specification</a>
 */
@EnableTestLogger
class MultiIssuerJWTTokenAuthenticatorExtendedTest {

    @TempDir Path tempDir;

    private TestRunner testRunner;
    private MultiIssuerJWTTokenAuthenticator processor;
    private final Map<String, String> dynamicProperties = new HashMap<>();

    private Path jwksFile;

    @BeforeEach
    void setup() throws IOException {
        processor = new MultiIssuerJWTTokenAuthenticator() {
            @Override
            public void onScheduled(final ProcessContext context) {
                MockProcessContext mockContext = (MockProcessContext) context;
                dynamicProperties.forEach(mockContext::setProperty);
                super.onScheduled(context);
            }
        };
        testRunner = TestRunners.newTestRunner(processor);

        // Write JWKS to temp file for file-based loading
        String jwksContent = InMemoryJWKSFactory.createDefaultJwks();
        jwksFile = tempDir.resolve("test-jwks.json");
        Files.writeString(jwksFile, jwksContent);

        // Configure basic properties
        testRunner.setProperty(Properties.TOKEN_LOCATION, "AUTHORIZATION_HEADER");
        testRunner.setProperty(Properties.TOKEN_HEADER, "Authorization");
        testRunner.setProperty(Properties.BEARER_TOKEN_PREFIX, "Bearer");

        // Configure issuer with file-based JWKS matching TestTokenHolder key material
        setDynamicProperty(ISSUER_PREFIX + "test-issuer.jwks-file", jwksFile.toAbsolutePath().toString());
        setDynamicProperty(ISSUER_PREFIX + "test-issuer.issuer", TestTokenHolder.TEST_ISSUER);
        setDynamicProperty(ISSUER_PREFIX + "test-issuer.audience", TestTokenHolder.TEST_AUDIENCE);
        setDynamicProperty(ISSUER_PREFIX + "test-issuer.client-id", TestTokenHolder.TEST_CLIENT_ID);
    }

    private void setDynamicProperty(String key, String value) {
        testRunner.setProperty(key, value);
        dynamicProperties.put(key, value);
    }

    private MockFlowFile enqueueWithToken(String token) {
        Map<String, String> attributes = new HashMap<>();
        attributes.put("http.headers.authorization", "Bearer " + token);
        testRunner.enqueue("test data", attributes);
        testRunner.run();
        return null; // Caller retrieves from relationship
    }

    @Nested
    @DisplayName("Successful Token Validation")
    class SuccessfulValidationTests {

        @Test
        @DisplayName("Should route valid RS256 token to SUCCESS")
        void shouldRouteValidTokenToSuccess() {
            TestTokenHolder tokenHolder = TestTokenGenerators.accessTokens().next();
            String token = tokenHolder.getRawToken();

            enqueueWithToken(token);

            testRunner.assertTransferCount(Relationships.SUCCESS, 1);
            testRunner.assertTransferCount(Relationships.AUTHENTICATION_FAILED, 0);

            MockFlowFile flowFile = testRunner.getFlowFilesForRelationship(Relationships.SUCCESS).getFirst();
            flowFile.assertAttributeEquals(JWTAttributes.Token.PRESENT, "true");
            flowFile.assertAttributeExists(JWTAttributes.Token.VALIDATED_AT);

            LogAsserts.assertLogMessagePresentContaining(TestLogLevel.INFO,
                    AuthLogMessages.INFO.PROCESSOR_INITIALIZED.resolveIdentifierString());
            LogAsserts.assertLogMessagePresentContaining(TestLogLevel.INFO,
                    AuthLogMessages.INFO.TOKEN_VALIDATOR_INITIALIZED.resolveIdentifierString());
        }

        @Test
        @DisplayName("Should extract subject from validated token")
        void shouldExtractSubject() {
            TestTokenHolder tokenHolder = TestTokenGenerators.accessTokens().next();
            enqueueWithToken(tokenHolder.getRawToken());

            testRunner.assertTransferCount(Relationships.SUCCESS, 1);
            MockFlowFile flowFile = testRunner.getFlowFilesForRelationship(Relationships.SUCCESS).getFirst();

            flowFile.assertAttributeExists(JWTAttributes.Token.SUBJECT);
            flowFile.assertAttributeEquals(JWTAttributes.Token.ISSUER, TestTokenHolder.TEST_ISSUER);
            flowFile.assertAttributeExists(JWTAttributes.Token.EXPIRATION);
        }

        @Test
        @DisplayName("Should extract custom claims as flow file attributes")
        void shouldExtractCustomClaims() {
            TestTokenHolder tokenHolder = TestTokenGenerators.accessTokens().next();
            tokenHolder.withClaim("tenant-id", ClaimValue.forPlainString("acme-corp"));

            enqueueWithToken(tokenHolder.getRawToken());

            testRunner.assertTransferCount(Relationships.SUCCESS, 1);
            MockFlowFile flowFile = testRunner.getFlowFilesForRelationship(Relationships.SUCCESS).getFirst();
            flowFile.assertAttributeEquals(JWTAttributes.Content.PREFIX + "tenant-id", "acme-corp");
        }

        @Test
        @DisplayName("Should reject token without subject claim")
        void shouldRejectTokenWithoutSubject() {
            TestTokenHolder tokenHolder = TestTokenGenerators.accessTokens().next();
            tokenHolder.withoutClaim("sub");

            enqueueWithToken(tokenHolder.getRawToken());

            // Token without 'sub' claim fails validation in oauth-sheriff
            testRunner.assertTransferCount(Relationships.AUTHENTICATION_FAILED, 1);
            testRunner.assertTransferCount(Relationships.SUCCESS, 0);

            LogAsserts.assertLogMessagePresentContaining(TestLogLevel.WARN, AuthLogMessages.WARN.TOKEN_VALIDATION_FAILED_MSG.resolveIdentifierString());
        }

        @Test
        @DisplayName("Should validate multiple different tokens in sequence")
        void shouldValidateMultipleTokensInSequence() {
            for (int i = 0; i < 3; i++) {
                TestTokenHolder tokenHolder = TestTokenGenerators.accessTokens().next();
                enqueueWithToken(tokenHolder.getRawToken());
            }

            testRunner.assertTransferCount(Relationships.SUCCESS, 3);
            testRunner.assertTransferCount(Relationships.AUTHENTICATION_FAILED, 0);
        }

        @Test
        @DisplayName("Should extract token from flow file content")
        void shouldExtractTokenFromContent() {
            testRunner.setProperty(Properties.TOKEN_LOCATION, "FLOW_FILE_CONTENT");

            TestTokenHolder tokenHolder = TestTokenGenerators.accessTokens().next();
            testRunner.enqueue(tokenHolder.getRawToken());
            testRunner.run();

            testRunner.assertTransferCount(Relationships.SUCCESS, 1);
        }

        @Test
        @DisplayName("Should extract token from custom header")
        void shouldExtractTokenFromCustomHeader() {
            testRunner.setProperty(Properties.TOKEN_LOCATION, "CUSTOM_HEADER");
            testRunner.setProperty(Properties.CUSTOM_HEADER_NAME, "X-JWT-Token");

            TestTokenHolder tokenHolder = TestTokenGenerators.accessTokens().next();
            Map<String, String> attributes = new HashMap<>();
            attributes.put("http.headers.x-jwt-token", tokenHolder.getRawToken());
            testRunner.enqueue("test data", attributes);
            testRunner.run();

            testRunner.assertTransferCount(Relationships.SUCCESS, 1);
        }
    }

    @Nested
    @DisplayName("Authorization Tests with Real Tokens")
    class AuthorizationWithRealTokensTests {

        @Test
        @DisplayName("Should route valid token to SUCCESS with authorization attribute set")
        void shouldRouteToSuccessWithAuthorizationAttribute() {
            TestTokenHolder tokenHolder = TestTokenGenerators.accessTokens().next();
            enqueueWithToken(tokenHolder.getRawToken());

            testRunner.assertTransferCount(Relationships.SUCCESS, 1);
            MockFlowFile flowFile = testRunner.getFlowFilesForRelationship(Relationships.SUCCESS).getFirst();
            // Authorization attribute is always set on successfully validated tokens
            flowFile.assertAttributeExists(JWTAttributes.Authorization.AUTHORIZED);
        }

        @Test
        @DisplayName("Should route token to SUCCESS even with scope configuration")
        void shouldRouteToSuccessWithScopeConfiguration() {
            TestTokenHolder tokenHolder = TestTokenGenerators.accessTokens().next();
            tokenHolder.withClaim("scope", ClaimValue.forPlainString("read write"));

            setDynamicProperty(ISSUER_PREFIX + "test-issuer." + JWTPropertyKeys.Issuer.REQUIRED_SCOPES, "read");

            enqueueWithToken(tokenHolder.getRawToken());

            // Token validation succeeds and routes to SUCCESS
            testRunner.assertTransferCount(Relationships.SUCCESS, 1);
            MockFlowFile flowFile = testRunner.getFlowFilesForRelationship(Relationships.SUCCESS).getFirst();
            flowFile.assertAttributeExists(JWTAttributes.Authorization.AUTHORIZED);
        }
    }

    @Nested
    @DisplayName("Lifecycle Tests")
    class LifecycleTests {

        @Test
        @DisplayName("Should handle onStopped after processing")
        void shouldHandleOnStoppedAfterProcessing() {
            TestTokenHolder tokenHolder = TestTokenGenerators.accessTokens().next();
            enqueueWithToken(tokenHolder.getRawToken());

            testRunner.assertTransferCount(Relationships.SUCCESS, 1);

            // onStopped is public API — should not throw
            assertDoesNotThrow(() -> processor.onStopped());

            LogAsserts.assertLogMessagePresentContaining(TestLogLevel.INFO,
                    AuthLogMessages.INFO.PROCESSOR_STOPPED.resolveIdentifierString());
        }

        @Test
        @DisplayName("Should reinitialize after stop and reschedule")
        void shouldReinitializeAfterStopAndReschedule() {
            // First run
            TestTokenHolder tokenHolder1 = TestTokenGenerators.accessTokens().next();
            enqueueWithToken(tokenHolder1.getRawToken());
            testRunner.assertTransferCount(Relationships.SUCCESS, 1);

            // Stop
            processor.onStopped();

            // Second run — processor reinitializes on next trigger
            testRunner.clearTransferState();
            TestTokenHolder tokenHolder2 = TestTokenGenerators.accessTokens().next();
            enqueueWithToken(tokenHolder2.getRawToken());
            testRunner.assertTransferCount(Relationships.SUCCESS, 1);
        }
    }

    @Nested
    @DisplayName("Configuration Change Detection")
    class ConfigurationChangeTests {

        @Test
        @DisplayName("Should detect issuer configuration changes between runs")
        void shouldDetectConfigurationChanges() {
            // First run with original issuer
            TestTokenHolder tokenHolder1 = TestTokenGenerators.accessTokens().next();
            enqueueWithToken(tokenHolder1.getRawToken());
            testRunner.assertTransferCount(Relationships.SUCCESS, 1);

            // Change audience — token should now fail validation
            testRunner.clearTransferState();
            setDynamicProperty(ISSUER_PREFIX + "test-issuer.audience", "wrong-audience");

            TestTokenHolder tokenHolder2 = TestTokenGenerators.accessTokens().next();
            enqueueWithToken(tokenHolder2.getRawToken());
            testRunner.assertTransferCount(Relationships.AUTHENTICATION_FAILED, 1);

            LogAsserts.assertLogMessagePresentContaining(TestLogLevel.INFO,
                    AuthLogMessages.INFO.CONFIG_CHANGE_DETECTED.resolveIdentifierString());
        }

        @Test
        @DisplayName("Should support adding a second issuer at runtime")
        void shouldSupportAddingSecondIssuer() {
            // First run succeeds with original issuer
            TestTokenHolder tokenHolder = TestTokenGenerators.accessTokens().next();
            enqueueWithToken(tokenHolder.getRawToken());
            testRunner.assertTransferCount(Relationships.SUCCESS, 1);

            // Add a second issuer configuration (with same JWKS for simplicity)
            testRunner.clearTransferState();
            setDynamicProperty(ISSUER_PREFIX + "second-issuer.jwks-file", jwksFile.toAbsolutePath().toString());
            setDynamicProperty(ISSUER_PREFIX + "second-issuer.issuer", "second-issuer");
            setDynamicProperty(ISSUER_PREFIX + "second-issuer.audience", "second-audience");

            // Original issuer tokens should still validate
            TestTokenHolder tokenHolder2 = TestTokenGenerators.accessTokens().next();
            enqueueWithToken(tokenHolder2.getRawToken());
            testRunner.assertTransferCount(Relationships.SUCCESS, 1);
        }
    }

    @Nested
    @DisplayName("Dynamic Property Descriptor Tests")
    class DynamicPropertyDescriptorTests {

        @Test
        @DisplayName("Should create descriptor for issuer properties")
        void shouldCreateDescriptorForIssuerProperties() {
            PropertyDescriptor descriptor = processor.getSupportedDynamicPropertyDescriptor(ISSUER_PREFIX + "my-issuer.jwks-url");
            assertNotNull(descriptor);
            assertFalse(descriptor.isRequired());
            assertTrue(descriptor.isDynamic());
        }

        @Test
        @DisplayName("Should create descriptor for non-issuer dynamic properties")
        void shouldCreateDescriptorForNonIssuerProperties() {
            PropertyDescriptor descriptor = processor.getSupportedDynamicPropertyDescriptor("custom.property");
            assertNotNull(descriptor);
            assertFalse(descriptor.isRequired());
        }

        @Test
        @DisplayName("Should reject null property name")
        void shouldRejectNullPropertyName() {
            assertThrows(NullPointerException.class,
                    () -> processor.getSupportedDynamicPropertyDescriptor(null));
        }
    }
}
